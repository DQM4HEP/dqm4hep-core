/// \file DQMMonitorElementManager.h
/*
 *
 * DQMMonitorElementManager.h header template automatically generated by a class generator
 * Creation date : lun. aoï¿½t 17 2015
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

#ifndef DQM4HEP_MONITORELEMENTMANAGER_H
#define DQM4HEP_MONITORELEMENTMANAGER_H

// -- dqm4hep headers
#include <dqm4hep/Directory.h>
#include <dqm4hep/Internal.h>
#include <dqm4hep/Logging.h>
#include <dqm4hep/MonitorElement.h>
#include <dqm4hep/QualityTest.h>
#include <dqm4hep/StatusCodes.h>
#include <dqm4hep/Storage.h>
#include <dqm4hep/Path.h>
#include <dqm4hep/XmlHelper.h>
#include <dqm4hep/AllocatorHelper.h>
#include <dqm4hep/RootHeaders.h>

namespace dqm4hep {

  namespace core {

    /** MonitorElementManager class
     */
    class MonitorElementManager {
      typedef std::shared_ptr<QualityTest> QualityTestPtr;
      typedef std::shared_ptr<QualityTestFactory> QualityTestFactoryPtr;
      typedef std::map<const std::string, QualityTestPtr> QualityTestMap;
      typedef std::map<const std::string, const QualityTestFactoryPtr> QualityTestFactoryMap;

    public:
      /** Constructor
       */
      MonitorElementManager();

      /** Destructor
       */
      ~MonitorElementManager();

      /////////////////////////
      // DIRECTORY INTERFACE //
      /////////////////////////

      /** Go back to root directory
       */
      void cd();

      /** Go to directory 'dirName'
       */
      StatusCode cd(const std::string &dirName);

      /** Create the directory 'dirName'
       */
      StatusCode mkdir(const std::string &dirName);

      /** List the current directory content
       */
      // void ls(bool recursive = false);

      /** Get the current directory name
       */
      const std::string &pwd();

      /** Get the current directory full name
       */
      const std::string &fullPwd();

      /** Navigate backward in the directory structure
       */
      StatusCode goUp();

      /** Remove the directory 'dirName'
       */
      StatusCode rmdir(const std::string &dirName);

      /** Whether the directory exists
       */
      bool dirExists(const std::string &dirName) const;

    public:
      ///////////////////////////////
      // MONITOR ELEMENT INTERFACE //
      ///////////////////////////////

      /** Add a monitor element from an external source.
       *  WARNING : The ROOT object is owned by the framework.
       *  The caller must NOT delete the object
       */
      template <typename T>
      StatusCode addMonitorElement(const std::string &path, TObject *pObject, std::shared_ptr<T> &monitorElement);

      /** Read TObject from file and add it to list.
       *  The ROOT TObject is owned by the manager
       */
      template <typename T>
      StatusCode readMonitorElement(const std::string &fileName, const std::string &path, const std::string &name,
                                    std::shared_ptr<T> &monitorElement);

      /** Read TObject from file and add it to list.
       *  The ROOT TObject is owned by the manager
       */
      template <typename T>
      StatusCode readMonitorElement(TFile *pTFile, const std::string &path, const std::string &name,
                                    std::shared_ptr<T> &monitorElement);

      /** Book a monitor element using the ROOT TClass facility.
       *  The className is passed to TClass::GetClass() to get the corresponding
       *  TClass object handler. Note that to allocate the TObject:
       *    - the default constructor is used
       *    - ROOT object is disabled so that object with same can be allocated safely memory leak
       *  The resulting monitored TObject is owned by the manager
       */
      template <typename T>
      StatusCode bookMonitorElement(const std::string &className, const std::string &path, const std::string &name,
                                    std::shared_ptr<T> &monitorElement);

      /** Add a monitor element from an external source.
      *  WARNING : The ROOT object is NOT owned by the framework.
      *  The caller must delete the object on termination
       */
      template <typename T>
      StatusCode handleMonitorElement(const std::string &path, TObject *pObject, std::shared_ptr<T> &monitorElement);

      /** Book a monitor element. The objectType must inherit TObject and have a ROOT dictionnary.
       *
       */
      // template <typename T, typename ObjectType, typename... Args>
      // StatusCode bookObject(const std::string &path, const std::string &name, std::shared_ptr<T> &monitorElement,
      //                       AllocatorHelper<TObject, ObjectType, Args...> allocator, Args... args);
                            
      template <typename ObjectType, typename T, typename... Args>
      StatusCode bookObject(const std::string &path, const std::string &name, const std::string &title, std::shared_ptr<T> &monitorElement, Args... args);
      
      template <typename HistoType, typename T, typename... Args>
      StatusCode bookHisto(const std::string &path, const std::string &name, const std::string &title, std::shared_ptr<T> &monitorElement, Args... args);
      
      template <typename ScalarType, typename T, typename... Args>
      StatusCode bookScalar(const std::string &path, const std::string &name, const std::string &title, std::shared_ptr<T> &monitorElement, Args... args);
      
      /**
       *  @brief  Book a monitor element from the xml element
       *  
       *  @param  xmlElement the xml element to parse
       *  @param  monitorelement the monitor element to receive
       */
      template <typename T>
      StatusCode bookMonitorElement(TiXmlElement *xmlElement, std::shared_ptr<T> &monitorElement);

      /**
       * @brief  Open root file, find reference object and attach it to the monitor element
       *
       * @param  pMonitorElement the monitor element to attach the reference
       * @param  fileName        the root file name contaning the reference
       */
      template <typename T>
      StatusCode attachReference(std::shared_ptr<T> monitorElement, const std::string &fileName);
      
      /**
       *  @brief  Read monitor element described by the xml element from a root file
       *
       *  @param  pXmlElement the xml element describing the objects to read
       *  @param  readQTests whether to associate qtest to monitor elements
       */
      template <typename T>
      StatusCode readMonitorElements(TiXmlElement *const pXmlElement, bool readQTests = true);
      
      /**
       *  @brief  Read monitor element described by the xml element from a root file
       *
       *  @param  pXmlElement the xml element describing the objects to read
       *  @param  monitorelement the monitor element to receive
       */
      template <typename T>
      StatusCode readMonitorElement(const std::string &fileName, TiXmlElement *const pXmlElement, std::shared_ptr<T> &monitorElement);
      
      /**
       *  @brief  Write all monitor elements in the storage to json
       *  
       *  @param  object the json object to receive
       */
      void monitorElementsToJson(json &object) const;

    public:
      ///////////////////////
      // GETTERS INTERFACE //
      ///////////////////////

      /** Get all the monitor elements already booked by this module in all the directories
       */
      template <typename T>
      void getMonitorElements(std::vector<std::shared_ptr<T>> &monitorElements) const;

      /** Get the monitor element in the current directory (result by ptr reference)
       */
      template <typename T>
      StatusCode getMonitorElement(const std::string &name, std::shared_ptr<T> &monitorElement) const;

      /** Get the monitor element in the given directory (result by ptr reference)
       */
      template <typename T>
      StatusCode getMonitorElement(const std::string &dirName, const std::string &name,
                                   std::shared_ptr<T> &monitorElement) const;
      
      /**
       *  @brief  Reset all monitor elements
       */
      void resetMonitorElements();

      ////////////////////////
      // DELETION INTERFACE //
      ////////////////////////

      /** Remove the monitor element
       */
      StatusCode removeMonitorElement(const std::string &path, const std::string &name);

    public:
      ////////////////////////////
      // QUALITY TEST INTERFACE //
      ////////////////////////////

      /** Create quality tests from the xml element.
       */
      StatusCode createQualityTests(TiXmlElement *const pXmlElement);      
      
      /** Create a quality test from the xml element.
       *  The xml element must contain the attribute 'type' and 'name'
       */
      StatusCode createQualityTest(TiXmlElement *const pXmlElement, float warning = QualityTest::defaultWarningLimit(), float error = QualityTest::defaultErrorLimit());

      /** Add a (already created) quality test to the monitor element
       */
      StatusCode addQualityTest(const std::string &path, const std::string &name, const std::string &qualityTestName);

      /** Remove a quality test from the monitor element
       */
      StatusCode removeQualityTest(const std::string &path, const std::string &name,
                                   const std::string &qualityTestName);

      /**
       */
      StatusCode runQualityTests(QReportStorage &reports);

      /**
       */
      StatusCode runQualityTests(const std::string &path, const std::string &name, QReportStorage &reports);

      /**
       */
      StatusCode runQualityTest(const std::string &path, const std::string &name, const std::string &qualityTestName,
                                QReportStorage &reports);

    private:
      
      bool checkClass(TClass *cls);
      StatusCode addToStorage(const std::string &path, MonitorElementPtr element);
      template <typename T>
      StatusCode createAndAddMonitorElement(const std::string &path, TObject *pObject, std::shared_ptr<T> &monitorElement, bool owner);
      
      template <typename T, typename... Args>
      std::shared_ptr<T> createMonitorElement(Args ...args);
      
      /** Get the monitor element storage
       */
      const Storage<MonitorElement> &getStorage() const;
      
      template <typename T>
      void doROOTNotOwner(T function);
      
    private:
      typedef std::shared_ptr<TObjectXMLAllocator> XMLAllocatorPtr;
      typedef std::map<MonitorElementPtr, QualityTestMap> MonitorElementToQTestMap;
      typedef std::map<std::string, XMLAllocatorPtr> XMLAllocatorMap;

      Storage<MonitorElement> m_storage = {};
      QualityTestFactoryMap m_qualityTestFactoryMap = {};
      QualityTestMap m_qualityTestMap = {};
      MonitorElementToQTestMap m_monitorElementToQTestMap = {};
      XMLAllocatorMap              m_xmlAllocatorMap = {};
      XMLAllocatorPtr              m_defaultXMLAllocator = {nullptr};
    };

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    template <typename T>
    inline void MonitorElementManager::getMonitorElements(std::vector<std::shared_ptr<T>> &monitorElements) const {
      m_storage.getObjects(monitorElements);
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename T>
    inline StatusCode MonitorElementManager::getMonitorElement(const std::string &name,
                                                        std::shared_ptr<T> &monitorElement) const {
      monitorElement = std::dynamic_pointer_cast<T>(m_storage.findObject([&name](const MonitorElementPtr &elt) { return (elt->name() == name); }));

      if (nullptr == monitorElement)
        return STATUS_CODE_NOT_FOUND;

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    template <typename T>
    inline StatusCode MonitorElementManager::getMonitorElement(const std::string &dirName, const std::string &name,
                                                        std::shared_ptr<T> &monitorElement) const {
      monitorElement = std::dynamic_pointer_cast<T>(
          m_storage.findObject(dirName, [&name](const MonitorElementPtr &elt) { return (elt->name() == name); }));

      if (nullptr == monitorElement)
        return STATUS_CODE_NOT_FOUND;

      return STATUS_CODE_SUCCESS;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename ObjectType, typename T, typename... Args>
    inline StatusCode MonitorElementManager::bookObject(const std::string &path, const std::string &name, const std::string &title, std::shared_ptr<T> &monitorElement, Args... args) {
      monitorElement = nullptr;
      if(not checkClass(ObjectType::Class())) {
        return STATUS_CODE_NOT_ALLOWED;
      }
      TObject *pTObject = nullptr;
      doROOTNotOwner([&](){
        pTObject = new ObjectType(args...);
      });
      if (!pTObject) {
        dqm_warning("Couldn't allocate monitor element of type '{0}', path '{1}', name '{2}'", ObjectType::Class_Name(),
                    path, name);
        return STATUS_CODE_FAILURE;
      }
      ((TNamed *)pTObject)->SetNameTitle(name.c_str(), title.c_str());
      return addMonitorElement<T>(path, pTObject, monitorElement);
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename HistoType, typename T, typename... Args>
    inline StatusCode MonitorElementManager::bookHisto(const std::string &path, const std::string &name, const std::string &title, std::shared_ptr<T> &monitorElement, Args... args) {
      monitorElement = nullptr;
      if(not checkClass(HistoType::Class())) {
        return STATUS_CODE_NOT_ALLOWED;
      }
      TObject *pTObject = nullptr;
      doROOTNotOwner([&](){
        pTObject = new HistoType(name.c_str(), title.c_str(), args...);
      });
      if (!pTObject) {
        dqm_warning("Couldn't allocate monitor element of type '{0}', path '{1}', name '{2}'", HistoType::Class_Name(), path, name);
        return STATUS_CODE_FAILURE;
      }
      return addMonitorElement<T>(path, pTObject, monitorElement);
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename ScalarType, typename T, typename... Args>
    inline StatusCode MonitorElementManager::bookScalar(const std::string &path, const std::string &name, const std::string &title, std::shared_ptr<T> &monitorElement, Args... args) {
      monitorElement = nullptr;
      if(not checkClass(TScalarObject<ScalarType>::Class())) {
        return STATUS_CODE_NOT_ALLOWED;
      }
      TObject *pTObject = nullptr;
      doROOTNotOwner([&](){
        pTObject = new TScalarObject<ScalarType>(args...);
      });
      if (!pTObject) {
        dqm_warning("Couldn't allocate monitor element of type '{0}', path '{1}', name '{2}'", TScalarObject<ScalarType>::Class_Name(), path, name);
        return STATUS_CODE_FAILURE;
      }
      ((TNamed *)pTObject)->SetNameTitle(name.c_str(), title.c_str());
      return addMonitorElement<T>(path, pTObject, monitorElement);
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename T, typename... Args>
    inline std::shared_ptr<T> MonitorElementManager::createMonitorElement(Args ...args) {
      return T::make_shared(args...);
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename T>
    inline StatusCode MonitorElementManager::createAndAddMonitorElement(const std::string &path, TObject *pObject, std::shared_ptr<T> &monitorElement, bool owner) {
      PtrHandler<TObject> ptrObject(pObject, owner);
      monitorElement = nullptr;
      TClass *cls = TClass::GetClass(pObject->ClassName());
      if(not checkClass(cls)) {
        return STATUS_CODE_NOT_ALLOWED;
      }
      monitorElement = createMonitorElement<T>(ptrObject);
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, addToStorage(path, monitorElement));
      return STATUS_CODE_SUCCESS;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename T>
    StatusCode MonitorElementManager::addMonitorElement(const std::string &path, TObject *pObject, std::shared_ptr<T> &monitorElement) {
      return createAndAddMonitorElement<T>(path, pObject, monitorElement, true);
    }
    
    //-------------------------------------------------------------------------------------------------

    template <typename T>
    inline StatusCode MonitorElementManager::handleMonitorElement(const std::string &path, TObject *pObject,
                                                           std::shared_ptr<T> &monitorElement) {
      return createAndAddMonitorElement<T>(path, pObject, monitorElement, false);
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename T>
    inline StatusCode MonitorElementManager::readMonitorElement(const std::string &fileName, const std::string &path,
                                                         const std::string &name, std::shared_ptr<T> &monitorElement) {
      monitorElement = nullptr;
      std::unique_ptr<TFile> rootFile(new TFile(fileName.c_str(), "READ"));
      return readMonitorElement<T>(rootFile.get(), path, name, monitorElement);
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename T>
    inline StatusCode MonitorElementManager::readMonitorElement(TFile *pTFile, const std::string &path, const std::string &name, std::shared_ptr<T> &monitorElement) {
      monitorElement = nullptr;
      Path fullName = path;
      fullName += name;
      const std::string queryPath = (path == "/") ? name : fullName.getPath();
      TObject *pTObject = nullptr;
      doROOTNotOwner([&](){
        auto local = pTFile->Get(queryPath.c_str());
        if(nullptr != local) {
          pTObject = local->Clone();
        }
      });
      if (pTObject == nullptr) {
        return STATUS_CODE_NOT_FOUND;
      }
      return addMonitorElement<T>(path, pTObject, monitorElement);
    }
    
    //-------------------------------------------------------------------------------------------------

    template <typename T>
    inline StatusCode MonitorElementManager::bookMonitorElement(const std::string &className, const std::string &path,
                                                         const std::string &name, std::shared_ptr<T> &monitorElement) {
      monitorElement = nullptr;
      TClass *pTClass = TClass::GetClass(className.c_str());
      if(not checkClass(pTClass)) {
        return STATUS_CODE_NOT_ALLOWED;
      }
      TObject *pTObject = nullptr;
      doROOTNotOwner([&](){
        pTObject = (TObject *)pTClass->New();
      });
      if (pTObject == nullptr) {
        dqm_error("MonitorElementManager::bookMonitorElement: Couldn't allocate ROOT class '{0}' from TClass facility",
                  className);
        return STATUS_CODE_FAILURE;
      }
      ((TNamed *)pTObject)->SetName(name.c_str());
      return addMonitorElement<T>(path, pTObject, monitorElement);
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename T>
    inline StatusCode MonitorElementManager::bookMonitorElement(TiXmlElement *xmlElement, std::shared_ptr<T> &monitorElement) {
      if(nullptr == xmlElement) {
        return STATUS_CODE_INVALID_PTR;
      }
      std::string className, name, path, title;
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::getAttribute(xmlElement, "type", className));
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::getAttribute(xmlElement, "name", name));
      RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::getAttribute(xmlElement, "path", path));
      RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::getAttribute(xmlElement, "title", title));
      
      auto findIter = m_xmlAllocatorMap.find(className);
      XMLAllocatorPtr allocator = (m_xmlAllocatorMap.end() == findIter) ? m_defaultXMLAllocator : findIter->second;
      TObject *pTObject = nullptr;
      doROOTNotOwner([&](){
        pTObject = allocator->create(xmlElement);
      });
      if(nullptr == pTObject) {
        dqm_error( "Object of type '{0}' couldn't be created from xml element !", className );
      }
      ((TNamed *)pTObject)->SetNameTitle(name.c_str(), title.c_str());
      return addMonitorElement<T>(path, pTObject, monitorElement);
    }
    
    //-------------------------------------------------------------------------------------------------

    template <typename T>
    inline StatusCode MonitorElementManager::attachReference(std::shared_ptr<T> monitorElement, const std::string &fileName) {
      if (nullptr == monitorElement)
        return STATUS_CODE_INVALID_PTR;

      Path fullName = monitorElement->path();
      fullName += monitorElement->name();
      dqm_debug("MonitorElementManager::attachReference: looking for element {0}", fullName.getPath());

      std::unique_ptr<TFile> rootFile(new TFile(fileName.c_str(), "READ"));

      const std::string queryPath = (monitorElement->path() == "/") ? monitorElement->name() : fullName.getPath();
      TObject *pTObject = nullptr;
      doROOTNotOwner([&](){
        auto local = rootFile->Get(queryPath.c_str());
        if(nullptr != local) {
          pTObject = local->Clone();
        }
      });
      if (pTObject == nullptr)
        return STATUS_CODE_NOT_FOUND;

      monitorElement->setReferenceObject(pTObject);

      return STATUS_CODE_SUCCESS;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename T>
    inline StatusCode MonitorElementManager::readMonitorElements(TiXmlElement *const pXmlElement, bool readQTests) {
      if(nullptr == pXmlElement) {
        dqm_error( "MonitorElementManager::readMonitorElements: Invalid xml element !" );
        return STATUS_CODE_INVALID_PTR;
      }
      for (TiXmlElement *child = pXmlElement->FirstChildElement(); child != nullptr; child = child->NextSiblingElement()) {
        std::shared_ptr<T> monitorElement;
        if(child->ValueStr() == "bookElement") {
          RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, bookMonitorElement<T>(child, monitorElement));
        }
        else if(child->ValueStr() == "fileElement") {
          std::string rootFile;
          RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::getAttribute(child, "file", rootFile));
          RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, readMonitorElement<T>(rootFile, child, monitorElement));
        }
        else if(child->ValueStr() == "file") {
          std::string rootFile;
          RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::getAttribute(child, "name", rootFile));
          for (TiXmlElement *child2 = child->FirstChildElement("fileElement"); child2 != nullptr; child2 = child2->NextSiblingElement("fileElement")) {
            // read sub-element
            std::shared_ptr<T> monitorElement2;
            RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, readMonitorElement<T>(rootFile, child2, monitorElement2));
            // attach quality tests if option set
            if(readQTests) {
              for (TiXmlElement *qtest = child2->FirstChildElement("qtest"); qtest != nullptr; qtest = qtest->NextSiblingElement("qtest")) {
                std::string qTestName;
                RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::getAttribute(qtest, "name", qTestName));
                RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, addQualityTest(monitorElement2->path(), monitorElement2->name(), qTestName));
              }          
            }
          }
          continue;
        }
        else {
          continue;
        }
        // attach quality tests if option set
        if(readQTests) {
          for (TiXmlElement *qtest = child->FirstChildElement("qtest"); qtest != nullptr; qtest = qtest->NextSiblingElement("qtest")) {
            std::string qTestName;
            RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::getAttribute(qtest, "name", qTestName));
            RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, addQualityTest(monitorElement->path(), monitorElement->name(), qTestName));
          }          
        }
      }
      return STATUS_CODE_SUCCESS;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename T>
    inline StatusCode MonitorElementManager::readMonitorElement(const std::string &fileName, TiXmlElement *const pXmlElement, std::shared_ptr<T> &monitorElement) {
      std::string path, name;
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::getAttribute(pXmlElement, "name", name));
      RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::getAttribute(pXmlElement, "path", path));
      // read element from root file
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, readMonitorElement<T>(fileName, path, name, monitorElement));
      return STATUS_CODE_SUCCESS;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename T>
    void MonitorElementManager::doROOTNotOwner(T userFunction) {
      const bool objectStat(TObject::GetObjectStat());
      const bool directoryStatus(TH1::AddDirectoryStatus());
      TObject::SetObjectStat(false);
      TH1::AddDirectory(false);
      userFunction();
      TH1::AddDirectory(directoryStatus);
      TObject::SetObjectStat(objectStat);
    }
    
  }
  
}

#endif //  DQM4HEP_MONITORELEMENTMANAGER_H
