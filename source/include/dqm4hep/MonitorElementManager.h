/// \file DQMMonitorElementManager.h
/*
 *
 * DQMMonitorElementManager.h header template automatically generated by a class generator
 * Creation date : lun. aoï¿½t 17 2015
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

#ifndef DQM4HEP_MONITORELEMENTMANAGER_H
#define DQM4HEP_MONITORELEMENTMANAGER_H

// -- dqm4hep headers
#include <dqm4hep/Directory.h>
#include <dqm4hep/Internal.h>
#include <dqm4hep/Logging.h>
#include <dqm4hep/MonitorElement.h>
#include <dqm4hep/QualityTest.h>
#include <dqm4hep/StatusCodes.h>
#include <dqm4hep/Storage.h>
#include <dqm4hep/Path.h>
#include <dqm4hep/XmlHelper.h>
#include <dqm4hep/AllocatorHelper.h>

// -- root headers
#include <TFile.h>
#include <TObject.h>
#include <TClass.h>

namespace dqm4hep {

  namespace core {

    /** MonitorElementManager class
     */
    class MonitorElementManager {
      typedef std::shared_ptr<QualityTest> QualityTestPtr;
      typedef std::shared_ptr<QualityTestFactory> QualityTestFactoryPtr;
      typedef std::map<const std::string, QualityTestPtr> QualityTestMap;
      typedef std::map<const std::string, const QualityTestFactoryPtr> QualityTestFactoryMap;

    public:
      /** Constructor
       */
      MonitorElementManager();

      /** Destructor
       */
      ~MonitorElementManager();

      /////////////////////////
      // DIRECTORY INTERFACE //
      /////////////////////////

      /** Go back to root directory
       */
      void cd();

      /** Go to directory 'dirName'
       */
      StatusCode cd(const std::string &dirName);

      /** Create the directory 'dirName'
       */
      StatusCode mkdir(const std::string &dirName);

      /** List the current directory content
       */
      // void ls(bool recursive = false);

      /** Get the current directory name
       */
      const std::string &pwd();

      /** Get the current directory full name
       */
      const std::string &fullPwd();

      /** Navigate backward in the directory structure
       */
      StatusCode goUp();

      /** Remove the directory 'dirName'
       */
      StatusCode rmdir(const std::string &dirName);

      /** Whether the directory exists
       */
      bool dirExists(const std::string &dirName) const;

    public:
      ///////////////////////////////
      // MONITOR ELEMENT INTERFACE //
      ///////////////////////////////

      /** Add a monitor element from an external source.
       *  WARNING : The ROOT object is owned by the framework.
       *  The caller must NOT delete the object
       */
      template <typename T>
      StatusCode addMonitorElement(const std::string &path, TObject *pObject, std::shared_ptr<T> &monitorElement);

      /** Read TObject from file and add it to list.
       *  The ROOT TObject is owned by the manager
       */
      template <typename T>
      StatusCode readMonitorElement(const std::string &fileName, const std::string &path, const std::string &name,
                                    std::shared_ptr<T> &monitorElement);

      /** Read TObject from file and add it to list.
       *  The ROOT TObject is owned by the manager
       */
      template <typename T>
      StatusCode readMonitorElement(TFile *pTFile, const std::string &path, const std::string &name,
                                    std::shared_ptr<T> &monitorElement);

      /** Book a monitor element using the ROOT TClass facility.
       *  The className is passed to TClass::GetClass() to get the corresponding
       *  TClass object handler. Note that to allocate the TObject:
       *    - the default constructor is used
       *    - ROOT object is disabled so that object with same can be allocated safely memory leak
       *  The resulting monitored TObject is owned by the manager
       */
      template <typename T>
      StatusCode bookMonitorElement(const std::string &className, const std::string &path, const std::string &name,
                                    std::shared_ptr<T> &monitorElement);

      /** Add a monitor element from an external source.
      *  WARNING : The ROOT object is NOT owned by the framework.
      *  The caller must delete the object on termination
       */
      template <typename T>
      StatusCode handleMonitorElement(const std::string &path, TObject *pObject, std::shared_ptr<T> &monitorElement);

      /** Book a monitor element. The objectType must inherit TObject and have a ROOT dictionnary.
       *
       */
      template <typename T, typename ObjectType, typename... Args>
      StatusCode bookObject(const std::string &path, const std::string &name, std::shared_ptr<T> &monitorElement,
                            AllocatorHelper<TObject, ObjectType, Args...> allocator, Args... args);

      /**
       * @brief  Open root file, find reference object and attach it to the monitor element
       *
       * @param  pMonitorElement the monitor element to attach the reference
       * @param  fileName        the root file name contaning the reference
       */
      template <typename T>
      StatusCode attachReference(std::shared_ptr<T> monitorElement, const std::string &fileName);
      
      /**
       *  @brief  Read monitor element described by the xml element from a root file
       *
       *  @param  pTFile the root file
       *  @param  pXmlElement the xml element describing the objects to read
       *  @param  readQTests whether to associate qtest to monitor elements
       */
      template <typename T>
      StatusCode readMonitorElements(TFile *pTFile, TiXmlElement *const pXmlElement, bool readQTests = true);
      
      /**
       *  @brief  Write all monitor elements in the storage to json
       *  
       *  @param  object the json object to receive
       */
      void monitorElementsToJson(json &object) const;

    public:
      ///////////////////////
      // GETTERS INTERFACE //
      ///////////////////////

      /** Get all the monitor elements already booked by this module in all the directories
       */
      template <typename T>
      void getMonitorElements(std::vector<std::shared_ptr<T>> &monitorElements) const;

      /** Get the monitor element in the current directory (result by ptr reference)
       */
      template <typename T>
      StatusCode getMonitorElement(const std::string &name, std::shared_ptr<T> &monitorElement) const;

      /** Get the monitor element in the given directory (result by ptr reference)
       */
      template <typename T>
      StatusCode getMonitorElement(const std::string &dirName, const std::string &name,
                                   std::shared_ptr<T> &monitorElement) const;

      ////////////////////////
      // DELETION INTERFACE //
      ////////////////////////

      /** Remove the monitor element
       */
      StatusCode removeMonitorElement(const std::string &path, const std::string &name);

    public:
      ////////////////////////////
      // QUALITY TEST INTERFACE //
      ////////////////////////////

      /** Create quality tests from the xml element.
       */
      StatusCode createQualityTests(TiXmlElement *const pXmlElement);      
      
      /** Create a quality test from the xml element.
       *  The xml element must contain the attribute 'type' and 'name'
       */
      StatusCode createQualityTest(TiXmlElement *const pXmlElement, float warning = QualityTest::defaultWarningLimit(), float error = QualityTest::defaultErrorLimit());

      /** Add a (already created) quality test to the monitor element
       */
      StatusCode addQualityTest(const std::string &path, const std::string &name, const std::string &qualityTestName);

      /** Remove a quality test from the monitor element
       */
      StatusCode removeQualityTest(const std::string &path, const std::string &name,
                                   const std::string &qualityTestName);

      /**
       */
      StatusCode runQualityTests(QReportStorage &reports);

      /**
       */
      StatusCode runQualityTests(const std::string &path, const std::string &name, QReportStorage &reports);

      /**
       */
      StatusCode runQualityTest(const std::string &path, const std::string &name, const std::string &qualityTestName,
                                QReportStorage &reports);

    private:
      
      bool checkClass(TClass *cls);
      StatusCode addToStorage(const std::string &path, MonitorElementPtr element);
      template <typename T>
      StatusCode createAndAddMonitorElement(const std::string &path, TObject *pObject, std::shared_ptr<T> &monitorElement, bool owner);
      
      template <typename T, typename... Args>
      std::shared_ptr<T> createMonitorElement(Args ...args);
      
      /** Get the monitor element storage
       */
      const Storage<MonitorElement> &getStorage() const;
      
    private:
      typedef std::map<MonitorElementPtr, QualityTestMap> MonitorElementToQTestMap;

      Storage<MonitorElement> m_storage = {};
      QualityTestFactoryMap m_qualityTestFactoryMap = {};
      QualityTestMap m_qualityTestMap = {};
      MonitorElementToQTestMap m_monitorElementToQTestMap = {};
    };

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    template <typename T>
    inline void MonitorElementManager::getMonitorElements(std::vector<std::shared_ptr<T>> &monitorElements) const {
      m_storage.getObjects(monitorElements);
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename T>
    inline StatusCode MonitorElementManager::getMonitorElement(const std::string &name,
                                                        std::shared_ptr<T> &monitorElement) const {
      monitorElement = std::dynamic_pointer_cast<T>(m_storage.findObject([&name](const MonitorElementPtr &elt) { return (elt->name() == name); }));

      if (nullptr == monitorElement)
        return STATUS_CODE_NOT_FOUND;

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    template <typename T>
    inline StatusCode MonitorElementManager::getMonitorElement(const std::string &dirName, const std::string &name,
                                                        std::shared_ptr<T> &monitorElement) const {
      monitorElement = std::dynamic_pointer_cast<T>(
          m_storage.findObject(dirName, [&name](const MonitorElementPtr &elt) { return (elt->name() == name); }));

      if (nullptr == monitorElement)
        return STATUS_CODE_NOT_FOUND;

      return STATUS_CODE_SUCCESS;
    }
    
    //-------------------------------------------------------------------------------------------------

    template <typename T, typename ObjectType, typename... Args>
    inline StatusCode MonitorElementManager::bookObject(const std::string &path, const std::string &name,
                                                 std::shared_ptr<T> &monitorElement,
                                                 AllocatorHelper<TObject, ObjectType, Args...> allocator,
                                                 Args... args) {
      monitorElement = nullptr;
      
      if(not checkClass(ObjectType::Class())) {
        return STATUS_CODE_NOT_ALLOWED;
      }

      const bool objectStat(TObject::GetObjectStat());
      TObject::SetObjectStat(false);
      TObject *pTObject = allocator.create(args...);
      TObject::SetObjectStat(objectStat);

      if (!pTObject) {
        dqm_warning("Couldn't allocate monitor element of type '{0}', path '{1}', name '{2}'", ObjectType::Class_Name(),
                    path, name);
        return STATUS_CODE_FAILURE;
      }

      ((TNamed *)pTObject)->SetName(name.c_str());
      return addMonitorElement<T>(path, pTObject, monitorElement);
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename T, typename... Args>
    inline std::shared_ptr<T> MonitorElementManager::createMonitorElement(Args ...args) {
      return T::make_shared(args...);
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename T>
    inline StatusCode MonitorElementManager::createAndAddMonitorElement(const std::string &path, TObject *pObject, std::shared_ptr<T> &monitorElement, bool owner) {
      PtrHandler<TObject> ptrObject(pObject, owner);
      monitorElement = nullptr;
      TClass *cls = TClass::GetClass(pObject->ClassName());
      if(not checkClass(cls)) {
        return STATUS_CODE_NOT_ALLOWED;
      }
      
      monitorElement = createMonitorElement<T>(ptrObject);
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, addToStorage(path, monitorElement));
      return STATUS_CODE_SUCCESS;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename T>
    StatusCode MonitorElementManager::addMonitorElement(const std::string &path, TObject *pObject, std::shared_ptr<T> &monitorElement) {
      return createAndAddMonitorElement<T>(path, pObject, monitorElement, true);
    }
    
    //-------------------------------------------------------------------------------------------------

    template <typename T>
    inline StatusCode MonitorElementManager::handleMonitorElement(const std::string &path, TObject *pObject,
                                                           std::shared_ptr<T> &monitorElement) {
      return createAndAddMonitorElement<T>(path, pObject, monitorElement, false);
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename T>
    inline StatusCode MonitorElementManager::readMonitorElement(const std::string &fileName, const std::string &path,
                                                         const std::string &name, std::shared_ptr<T> &monitorElement) {
      monitorElement = nullptr;
      std::unique_ptr<TFile> rootFile(new TFile(fileName.c_str(), "READ"));
      return readMonitorElement<T>(rootFile.get(), path, name, monitorElement);
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename T>
    inline StatusCode MonitorElementManager::readMonitorElement(TFile *pTFile, const std::string &path, const std::string &name, std::shared_ptr<T> &monitorElement) {
      monitorElement = nullptr;
      Path fullName = path;
      fullName += name;
      const bool objectStat(TObject::GetObjectStat());
      TObject::SetObjectStat(false);
      TObject *pTObject = nullptr;
      // FIXME : bad handling of path in root path
      if (path == "/")
        pTObject = pTFile->Get(name.c_str());
      else
        pTObject = pTFile->Get(fullName.getPath().c_str());
      TObject::SetObjectStat(objectStat);

      if (pTObject == nullptr)
        return STATUS_CODE_NOT_FOUND;

      return addMonitorElement<T>(path, pTObject, monitorElement);
    }
    
    //-------------------------------------------------------------------------------------------------

    template <typename T>
    inline StatusCode MonitorElementManager::bookMonitorElement(const std::string &className, const std::string &path,
                                                         const std::string &name, std::shared_ptr<T> &monitorElement) {
      monitorElement = nullptr;
      TClass *pTClass = TClass::GetClass(className.c_str());
      
      if(not checkClass(pTClass)) {
        return STATUS_CODE_NOT_ALLOWED;
      }

      const bool objectStat(TObject::GetObjectStat());
      TObject::SetObjectStat(false);
      TObject *pTObject = (TObject *)pTClass->New();
      TObject::SetObjectStat(objectStat);

      if (pTObject == nullptr) {
        dqm_error("MonitorElementManager::bookMonitorElement: Couldn't allocate ROOT class '{0}' from TClass facility",
                  className);
        return STATUS_CODE_FAILURE;
      }

      ((TNamed *)pTObject)->SetName(name.c_str());
      return addMonitorElement<T>(path, pTObject, monitorElement);
    }
    
    //-------------------------------------------------------------------------------------------------

    template <typename T>
    inline StatusCode MonitorElementManager::attachReference(std::shared_ptr<T> monitorElement, const std::string &fileName) {
      if (nullptr == monitorElement)
        return STATUS_CODE_INVALID_PTR;

      Path fullName = monitorElement->path();
      fullName += monitorElement->name();
      dqm_debug("MonitorElementManager::attachReference: looking for element {0}", fullName.getPath());

      std::unique_ptr<TFile> rootFile(new TFile(fileName.c_str(), "READ"));

      const bool objectStat(TObject::GetObjectStat());
      TObject::SetObjectStat(false);
      TObject *pTObject(nullptr);

      if (monitorElement->path() == "/")
        pTObject = rootFile->Get(monitorElement->name().c_str());
      else
        pTObject = rootFile->Get(fullName.getPath().c_str());

      TObject::SetObjectStat(objectStat);

      if (pTObject == nullptr)
        return STATUS_CODE_NOT_FOUND;

      monitorElement->setReferenceObject(pTObject);

      return STATUS_CODE_SUCCESS;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename T>
    inline StatusCode MonitorElementManager::readMonitorElements(TFile *pTFile, TiXmlElement *const pXmlElement, bool readQTests) {

      if(nullptr == pTFile) {
        dqm_error( "MonitorElementManager::readMonitorElements: Invalid TFile pointer !" );
        return STATUS_CODE_INVALID_PARAMETER;
      }
      
      if(nullptr == pXmlElement) {
        dqm_error( "MonitorElementManager::readMonitorElements: Invalid xml element !" );
        return STATUS_CODE_INVALID_PARAMETER;
      }
      
      for (TiXmlElement *meElt = pXmlElement->FirstChildElement("monitorElement"); meElt != nullptr; meElt = meElt->NextSiblingElement("monitorElement")) {
        
        std::string path, name, reference;
        RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::getAttribute(meElt, "path", path));
        RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::getAttribute(meElt, "reference", reference));
        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::getAttribute(meElt, "name", name));

        // read element from root file
        std::shared_ptr<T> monitorElement;
        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, readMonitorElement(pTFile, path, name, monitorElement));

        // read reference element if any
        if (!reference.empty()) {
          dqm_debug("Monitor element '{0}' read, reference file '{1}'", name, reference);
          RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, attachReference(monitorElement, reference));
        }
        
        // attach quality tests if option set
        if(readQTests) {
          for (TiXmlElement *qtest = meElt->FirstChildElement("qtest"); qtest != nullptr; qtest = qtest->NextSiblingElement("qtest")) {
            std::string qTestName;
            THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::getAttribute(qtest, "name", qTestName));
            THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->addQualityTest(path, name, qTestName));
          }          
        }
      }
      
      return STATUS_CODE_SUCCESS;
    }
    
  }
  
}

#endif //  DQM4HEP_MONITORELEMENTMANAGER_H
