/// \file EventReader.h
/*
 *
 * EventReader.h header template automatically generated by a class generator
 * Creation date : ven. sept. 5 2014
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef DQM4HEP_EVENTREADER_H
#define DQM4HEP_EVENTREADER_H

// -- dqm4hep headers
#include "dqm4hep/Internal.h"
#include "dqm4hep/StatusCodes.h"
#include "dqm4hep/Run.h"
#include "dqm4hep/Event.h"
#include "dqm4hep/Signal.h"

namespace dqm4hep {

  namespace core {
    
    /**
     *  @brief  EventReader class
     *
     *  Implement the logic of reading a file containing events.
     *  While reading the file, the daughter class has to use the
     *  available signal for notifying new events.
     *
     *  Typical use of event reader:
     *  @code
     *  // user custom class that cosume the data
     *  MyConsumer consumer;
     *  EventReader *reader = new MyFileReader();
     *  reader->onNewRun().connect(&consumer, &MyConsumer::processNewRun);
     *  reader->onEventRead().connect(&consumer, &MyConsumer::processEvent);
     *  reader->openFile("detector_I12548.raw");
     *  // skip 5 first events (not mandatory)
     *  reader->skipNEvents(5);
     *  while(STATUS_CODE_SUCCESS == reader->readNextEvent());
     * Â @endcode
     */
    class EventReader {
    public:
      /**
       *  @brief  Destructor
       */
      virtual ~EventReader();
      
      /**
       *  @brief  Open a new file
       *
       *  @param  fname the file name to open
       */
      virtual core::StatusCode open(const std::string &fname) = 0;
      
      /**
       *  @brief  Skip n events from the current position (usually from beginning of file)
       *  
       *  @param  nEvents the number of event to skip
       */
      virtual core::StatusCode skipNEvents(int nEvents) = 0;
      
      /**
       *  @brief  Extract the run info from file
       * 
       *  @param  run the run to receive
       */
      virtual core::StatusCode runInfo(core::Run &run) = 0;
      
      /**
       *  @brief  Read next event in the file and post it using the signal.
       *          STATUS_CODE_OUT_OF_RANGE is synonym of end of file.
       *          Anything else than STATUS_CODE_SUCCESS is considered as an error
       */
      virtual core::StatusCode readNextEvent() = 0;
      
      /**
       *  @brief  Close the current file
       */
      virtual core::StatusCode close() = 0;
      
      /**
       *  @brief  Get the signal on event read
       */
      core::Signal<core::EventPtr> &onEventRead();
      
    protected:
      /// The signal on event read
      core::Signal<core::EventPtr>              m_onEventRead = {};
    };
    
    typedef std::shared_ptr<EventReader> EventReaderPtr;
  }

} 

#endif  //  DQM4HEP_EVENTREADER_H
