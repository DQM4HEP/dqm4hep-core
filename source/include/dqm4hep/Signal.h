/// \file Signal.h
/*
*
* Signal.h header template automatically generated by a class generator
* Creation date : lun. janv. 23 2017
*
* This file is part of DQM4HEP libraries.
*
* DQM4HEP is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* based upon these libraries are permitted. Any copy of these libraries
* must include this copyright notice.
*
* DQM4HEP is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
*
* @author Remi Ete
* @copyright CNRS , IPNL
*/

#ifndef DQM4HEP_SIGNAL_H
#define DQM4HEP_SIGNAL_H

namespace dqm4hep {

  namespace core {

    /**
     *  @brief  SignalBase class (internal)
     *          Base class for emitting signals
     */
    template <typename... Args>
    class SignalBase {
    public:
      /**
       *  @brief  Destructor
       */
      virtual ~SignalBase() {
        /* nop */
      }

      /**
      *  @brief  Emit the signal
      */
      virtual void emit(Args... args) = 0;
    };

    /**
     *  @brief  SignalBase specialization (internal)
     *          No argument in callback function
     */
    template <>
    class SignalBase<void> {
    public:
      /**
       *  @brief  Destructor
       */
      virtual ~SignalBase() {
        /* nop */
      }

      /**
      *  @brief  Emit the signal
      */
      virtual void emit() = 0;
    };

    //----------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------

    /**
    *  @brief  SignalT class (internal)
    */
    template <typename T, typename... Args>
    class SignalT : public SignalBase<Args...> {
    public:
      typedef void (T::*Function)(Args...);

      /**
      *  @brief  Constructor
      */
      SignalT(T *object, Function function);

      /**
      *  @brief  Emit the signal
      *
      * @param  args the arguments to forward
      */
      void emit(Args... args);

      /**
       *  @brief  Get the class object
       */
      const T *object() const;

      /**
       *  @brief  Get the object member-function 
       */
      Function function() const;

    private:
      /// The class object
      T              *m_object = {nullptr};
      /// The object member-function
      Function        m_function = {};
    };

    // SPECIALIZATION - CLASS + VOID
    template <typename T>
    class SignalT<T, void> : public SignalBase<void> {
    public:
      typedef void (T::*Function)();

      /**
      *  @brief  Constructor with
      */
      SignalT(T *obj, Function func);

      /**
      *  @brief  Process the callback
      */
      void emit();

      /**
       *  @brief  Get the class object
       */
      const T *object() const;

      /**
       *  @brief  Get the object member-function 
       */
      Function function() const;

    private:
      /// The class object
      T              *m_object = {nullptr};
      /// The object member-function
      Function        m_function = {};
    };
    
    /// SPECIALIZATION - PURE FUNCTION + ARGS
    template <typename... Args>
    class SignalT<void, Args...> : public SignalBase<Args...> {
    public:
      typedef void (*Function)(Args...);

      /**
      *  @brief  Constructor
      */
      SignalT(Function function);

      /**
      *  @brief  Emit the signal
      */
      void emit(Args... args);

      /**
       *  @brief  Get the associated function 
       */
      Function function() const;

    private:
      /// The associated callback function
      Function        m_function = {};
    };
    
    // SPECIALIZATION - PURE FUNCTION + NO ARGS
    template <>
    class SignalT<void, void> : public SignalBase<void> {
    public:
      typedef void (*Function)();

      /**
      *  @brief  Constructor
      */
      SignalT(Function function);

      /**
      *  @brief  Emit the signal
      */
      void emit();

      /**
       *  @brief  Get the associated function 
       */
      Function function() const;

    private:
      /// The associated callback function
      Function        m_function = {};
    };

    //----------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------

    /**
     *  @brief Signal class
     *
     *  Implement the observer pattern a la Qt.
     *  Example:
     *  @code
     *
     *  void func() {
     *    std::cout << "Hello world !" << std::endl;
     *  }
     *
     *  class Toto {
     *  public:
     *    void hello() {
     *      std::cout << "Toto world !" << std::endl;
     *    }
     *  };
     *  
     *  Signal<> sig;
     *  Toto toto;
     *  sig.connect(func);
     *  sig.connect(&toto, &Toto::hello);
     *  sig.emit();
     *  @endcode
     *
     *  Allows nice and understandable piece of code like:
     *  @code
     *  // Holds a property and signal
     *  class Property {
     *  public:
     *    void setProperty(int value) {
     *      m_property = value;
     *      m_onUpdate.emit(m_property);
     *    }
     *    Signal<int> &onUpdate() {
     *      return m_onUpdate;
     *    }
     *  private:
     *    int           m_property = {0};
     *    Signal<int>   m_onUpdate = {};
     *  };
     *
     *  // To print the property !
     *  class Printer {
     *  public:
     *    void print(int value) {
     *      std::cout << "Value is " << value << std::endl;
     *    }
     *  };
     *  
     *  Printer printer;
     *  Property property;
     *  property.onUpdate().connect(&printer, &Printer::print); // I love this line !
     *  property.setProperty(42); // Calls 'print' method
     *  @endcode
     */
    template <typename... Args>
    class Signal {
    public:
      /**
       *  @brief  Default constructor
       */
      Signal() = default;
      
      /**
       *  @brief  Destructor
       */
      ~Signal();

      /**
       *  @brief  Emit the signal. This function is deprecated
       * 
       *  @param  args arguments to forward
       */      
      DEPRECATED(void process(Args... args));

      /**
       *  @brief  Emit the signal
       * 
       *  @param  args arguments to forward
       */
      void emit(Args... args);

      /**
       *  @brief  Connect a class member-function to signal
       *
       *  @param  object the class object
       *  @param  function the class member-function
       */
      template <typename T>
      bool connect(T *object, void (T::*function)(Args...));
      
      /**
       *  @brief  Connect a function to signal
       *  
       *  @param  function [description]
       */
      bool connect(void (*function)(Args...));

      /**
       *  @brief  Disconnect all functions of the target object 
       *
       *  @param  object the object target
       */
      template <typename T>
      bool disconnect(T *object);
      
      /**
       *  @brief  Disconnect a specific class member-function
       *
       *  @param  object the target object
       *  @param function the class member-function
       */
      template <typename T>
      bool disconnect(T *object, void (T::*function)(Args...));
      
      /**
       *  @brief  Disconnect a function
       *
       *  @param  object the target object
       *  @param function the class member-function
       */
      bool disconnect(void (*function)(Args...));

      /**
       *  @brief  Disconnect all functions
       */
      void disconnect();

      /**
       *  @brief  Whether the target object has any connected functions
       *
       *  @param  object the target object 
       */
      template <typename T>
      bool hasConnection(T *object) const;
      
      /**
       *  @brief  Whether the target object and member-function is connected
       *
       *  @param  object the target object 
       *  @param  function the class member-function
       */
      template <typename T>
      bool isConnected(T *object, void (T::*function)(Args...)) const;
      
      /**
       *  @brief  Whether the function is connected
       *
       *  @param  function the target function
       */
      bool isConnected(void (*function)(Args...)) const;

      /**
       *  @brief  Whether the signal has at least one connection 
       */
      bool hasConnection() const;
      
      /**
       *  @brief  Get the number of connected functions
       */
      size_t nConnections() const;

    private:
      /// The list of callbacks
      typename std::vector<SignalBase<Args...>*>   m_callbacks = {};
    };

    //----------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------

    template <typename... Args>
    inline Signal<Args...>::~Signal() {
      this->disconnect();
    }
    
    //----------------------------------------------------------------------------------
    
    template <typename... Args>
    inline void Signal<Args...>::process(Args... args) {
      emit(args...);
    }

    //----------------------------------------------------------------------------------

    template <typename... Args>
    inline void Signal<Args...>::emit(Args... args) {
      for (auto iter = m_callbacks.begin(), endIter = m_callbacks.end(); endIter != iter; ++iter) {
        (*iter)->emit(args...);
      }
    }

    //----------------------------------------------------------------------------------

    template <typename... Args>
    template <typename T>
    inline bool Signal<Args...>::connect(T *object, void (T::*function)(Args...)) {
      if (this->isConnected(object, function)) {
        return false;
      }
      m_callbacks.push_back(new SignalT<T, Args...>(object, function));
      return true;
    }
    
    //----------------------------------------------------------------------------------
    
    template <typename... Args>
    inline bool Signal<Args...>::connect(void (*function)(Args...)) {
      if (this->isConnected(function)) {
        return false;
      }
      m_callbacks.push_back(new SignalT<void, Args...>(function));
      return true;
    }

    //----------------------------------------------------------------------------------

    template <typename... Args>
    template <typename T>
    inline bool Signal<Args...>::disconnect(T *object) {
      bool disconnected = false;
      for (auto iter = m_callbacks.begin(), endIter = m_callbacks.end(); endIter != iter; ++iter) {
        auto callback = dynamic_cast<SignalT<T, Args...>*>(*iter);
        if(nullptr == callback) {
          continue;
        }
        if (callback->object() == object) {
          delete callback;
          m_callbacks.erase(iter);
          iter--;
          disconnected = true;
        }
      }
      return disconnected;
    }
    
    //----------------------------------------------------------------------------------
    
    template <typename... Args>
    template <typename T>
    inline bool Signal<Args...>::disconnect(T *object, void (T::*function)(Args...)) {
      for (auto iter = m_callbacks.begin(), endIter = m_callbacks.end(); endIter != iter; ++iter) {
        auto callback = dynamic_cast<SignalT<T, Args...>*>(*iter);
        if(nullptr == callback) {
          continue;
        }
        if (callback->object() == object && callback->function() == function) {
          delete callback;
          m_callbacks.erase(iter);
          return true;
        }
      }
      return false;
    }
    
    //----------------------------------------------------------------------------------
    
    template <typename... Args>
    inline bool Signal<Args...>::disconnect(void (*function)(Args...)) {
      for (auto iter = m_callbacks.begin(), endIter = m_callbacks.end(); endIter != iter; ++iter) {
        auto callback = dynamic_cast<SignalT<void, Args...>*>(*iter);
        if(nullptr == callback) {
          continue;
        }
        if (callback->function() == function) {
          delete callback;
          m_callbacks.erase(iter);
          return true;
        }
      }
      return false;
    }

    //----------------------------------------------------------------------------------

    template <typename... Args>
    inline void Signal<Args...>::disconnect() {
      for (auto iter = m_callbacks.begin(), endIter = m_callbacks.end(); endIter != iter; ++iter) {
        delete *iter;        
      }
      m_callbacks.clear();
    }

    //----------------------------------------------------------------------------------

    template <typename... Args>
    template <typename T>
    inline bool Signal<Args...>::hasConnection(T *object) const {
      for (auto iter = m_callbacks.begin(), endIter = m_callbacks.end(); endIter != iter; ++iter) {
        auto callback = dynamic_cast<const SignalT<T, Args...>*>(*iter);
        if (nullptr == callback) {
          continue;          
        }
        if (callback->object() == object) {
          return true;
        }
      }
      return false;
    }
    
    //----------------------------------------------------------------------------------

    template <typename... Args>
    template <typename T>
    inline bool Signal<Args...>::isConnected(T *object, void (T::*function)(Args...)) const {
      for (auto iter = m_callbacks.begin(), endIter = m_callbacks.end(); endIter != iter; ++iter) {
        auto callback = dynamic_cast<const SignalT<T, Args...>*>(*iter);
        if (nullptr == callback) {
          continue;          
        }
        if (callback->object() == object && callback->function() == function) {
          return true;
        }
      }
      return false;
    }
    
    //----------------------------------------------------------------------------------

    template <typename... Args>
    inline bool Signal<Args...>::isConnected(void (*function)(Args...)) const {
      for (auto iter = m_callbacks.begin(), endIter = m_callbacks.end(); endIter != iter; ++iter) {
        auto callback = dynamic_cast<const SignalT<void, Args...>*>(*iter);
        if (nullptr == callback) {
          continue;          
        }
        if (callback->function() == function) {
          return true;
        }
      }
      return false;
    }

    //----------------------------------------------------------------------------------

    template <typename... Args>
    inline bool Signal<Args...>::hasConnection() const {
      return (not m_callbacks.empty());
    }
    
    //----------------------------------------------------------------------------------
    
    template <typename... Args>
    inline size_t Signal<Args...>::nConnections() const {
      return m_callbacks.size();
    }

    //----------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------
    
    template <typename T, typename... Args>
    inline SignalT<T, Args...>::SignalT(T *object, Function function) : 
      m_object(object), 
      m_function(function) {
      /* nop */
    }
    
    //----------------------------------------------------------------------------------
    
    template <typename T, typename... Args>
    inline void SignalT<T, Args...>::emit(Args... args) {
      (m_object->*m_function)(args...);
    }
    
    //----------------------------------------------------------------------------------
    
    template <typename T, typename... Args>
    inline const T *SignalT<T, Args...>::object() const {
      return m_object;
    }
    
    //----------------------------------------------------------------------------------
    
    template <typename T, typename... Args>
    inline typename SignalT<T, Args...>::Function SignalT<T, Args...>::function() const {
      return m_function;
    }
    
    //----------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------
    
    template <typename T>
    inline SignalT<T, void>::SignalT(T *object, Function function) : 
      m_object(object), 
      m_function(function) {
      /* nop */
    }
    
    //----------------------------------------------------------------------------------
    
    template <typename T>
    inline void SignalT<T, void>::emit() {
      (m_object->*m_function)();
    }
    
    //----------------------------------------------------------------------------------
    
    template <typename T>
    inline const T *SignalT<T, void>::object() const {
      return m_object;
    }
    
    //----------------------------------------------------------------------------------
    
    template <typename T>
    inline typename SignalT<T, void>::Function SignalT<T, void>::function() const {
      return m_function;
    }
    
    //----------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------
    
    template <typename... Args>
    inline SignalT<void, Args...>::SignalT(Function function) :
      m_function(function) {
      /* nop */
    }
    
    //----------------------------------------------------------------------------------
    
    template <typename... Args>
    inline void SignalT<void, Args...>::emit(Args... args) {
      (*m_function)(args...);
    }
    
    //----------------------------------------------------------------------------------
    
    template <typename... Args>
    inline typename SignalT<void, Args...>::Function SignalT<void, Args...>::function() const {
      return m_function;
    }
    
    //----------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------
    
    inline SignalT<void, void>::SignalT(Function function) :
      m_function(function) {
      /* nop */
    }
    
    //----------------------------------------------------------------------------------
    
    inline void SignalT<void, void>::emit() {
      (*m_function)();
    }
    
    //----------------------------------------------------------------------------------
    
    inline typename SignalT<void, void>::Function SignalT<void, void>::function() const {
      return m_function;
    }
  }
}

#endif //  DQM4HEP_SIGNAL_H
