/// \file MonitorElementStreamer.h
/*
 *
 * MonitorElementStreamer.h header template automatically generated by a class generator
 * Creation date : mar. dï¿½c. 15 2015
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright
 */

#ifndef DQM4HEP_MONITORELEMENTSTREAMER_H
#define DQM4HEP_MONITORELEMENTSTREAMER_H

// -- dqm4hep headers
#include <dqm4hep/StatusCodes.h>
#include <dqm4hep/MonitorElement.h>
#include <dqm4hep/QualityTest.h>
#include <dqm4hep/Logging.h>

// -- xdrstream headers
#include <xdrstream/xdrstream.h>

namespace dqm4hep {

  namespace core {
    
    /**
     *  @brief  MonitorElementStreamer class
     */
    class MonitorElementStreamer {
    public:
      /**
       *  @brief  Default constructor
       */
      MonitorElementStreamer() = default;
      
      /**
       *  @brief  Default destructor
       */
      ~MonitorElementStreamer() = default;
      
      /**
       *  @brief  Write a monitor element using an xdrstream device.
       *          
       *  @param  monitorElement a shared pointer on a monitor element or sub-class of it
       *  @param  device the xdrstream device to write with
       */
      template <typename T>
      StatusCode writeMonitorElement(std::shared_ptr<T> monitorElement, xdrstream::IODevice *device);
      
      /**
       *  @brief  Read a monitor element using an xdrstream device.
       *          
       *  @param  monitorElement a shared pointer on a monitor element or sub-class of it
       *  @param  device the xdrstream device to read with
       */
      template <typename T>
      StatusCode readMonitorElement(std::shared_ptr<T> &monitorElement, xdrstream::IODevice *device);
      
      /**
       *  @brief  Write a list of monitor elements using an xdrstream device.
       * 
       *  @param  elements a vector of monitor elements to write
       *  @param  device the xdrstream device to write with
       */
      template <typename T>
      StatusCode writeMonitorElements(const std::vector<std::shared_ptr<T>> &elements, xdrstream::IODevice *device);
      
      /**
       *  @brief  Read a list of monitor elements using an xdrstream device.
       * 
       *  @param  elements a vector of monitor elements to receive
       *  @param  device the xdrstream device to read with
       */
      template <typename T>
      StatusCode readMonitorElements(std::vector<std::shared_ptr<T>> &elements, xdrstream::IODevice *device);
      
      /**
       *  @brief  Write a map of monitor elements using an xdrstream device.
       * 
       *  @param  elements a map of monitor element vector to write
       *  @param  device the xdrstream device to write with
       */
      template <typename T>
      StatusCode writeMonitorElements(const std::map<std::string,std::vector<std::shared_ptr<T>>> &elements, xdrstream::IODevice *device);
      
      /**
       *  @brief  Read a map of monitor elements using an xdrstream device.
       * 
       *  @param  elements a map of monitor element vector to receive
       *  @param  device the xdrstream device to read with
       */
      template <typename T>
      StatusCode readMonitorElements(std::map<std::string,std::vector<std::shared_ptr<T>>> &elements, xdrstream::IODevice *device);
    };
    
    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------
    
    template <typename T>
    inline StatusCode MonitorElementStreamer::writeMonitorElement(std::shared_ptr<T> monitorElement, xdrstream::IODevice *device) {
      if(nullptr == monitorElement or nullptr == device) {
        dqm_error( "Couldn't write monitor element to device: nullptr !" );
        return STATUS_CODE_INVALID_PTR;
      }
      return monitorElement->toDevice(device);
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename T>
    inline StatusCode MonitorElementStreamer::readMonitorElement(std::shared_ptr<T> &monitorElement, xdrstream::IODevice *device) {
      if(nullptr == device) {
        dqm_error( "Couldn't read monitor element from device: nullptr !" );
        return STATUS_CODE_INVALID_PTR;
      }
      std::shared_ptr<T> tmp = T::make_shared();
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, tmp->fromDevice(device));
      monitorElement = tmp;
      return STATUS_CODE_SUCCESS;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename T>
    inline StatusCode MonitorElementStreamer::writeMonitorElements(const std::vector<std::shared_ptr<T>> &elements, xdrstream::IODevice *device) {
      auto pos = device->getPosition();
      unsigned int nWritten = 0;
      XDRSTREAM_SUCCESS_RESTORE(device->write(&nWritten), pos);
      for(auto element : elements) {
        StatusCode writeCode = writeMonitorElement(element, device);
        if(writeCode != STATUS_CODE_SUCCESS) {
          device->seek(pos);
          return writeCode;
        }
        nWritten++;
      }
      // write the actual number of written monitor element at start position
      auto endPos = device->getPosition();
      device->seek(pos);
      XDRSTREAM_SUCCESS_RESTORE(device->write(&nWritten), pos);
      device->seek(endPos);
      return STATUS_CODE_SUCCESS;
    }
    
    //-------------------------------------------------------------------------------------------------

    template <typename T>
    inline StatusCode MonitorElementStreamer::readMonitorElements(std::vector<std::shared_ptr<T>> &elements, xdrstream::IODevice *device) {
      auto pos = device->getPosition();
      unsigned int nToRead = 0;
      XDRSTREAM_SUCCESS_RESTORE(device->read(&nToRead), pos);
      for(unsigned int i=0 ; i<nToRead ; ++i) {
        std::shared_ptr<T> element;
        StatusCode readCode = readMonitorElement(element, device);
        if(readCode != STATUS_CODE_SUCCESS) {
          device->seek(pos);
          return readCode;
        }
        elements.push_back(element);
      }
      return STATUS_CODE_SUCCESS;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename T>
    inline StatusCode MonitorElementStreamer::writeMonitorElements(const std::map<std::string,std::vector<std::shared_ptr<T>>> &elements, xdrstream::IODevice *device) {
      auto pos = device->getPosition();
      unsigned int nWritten = elements.size();
      XDRSTREAM_SUCCESS_RESTORE(device->write(&nWritten), pos);
      for(auto &iter : elements) {
        XDRSTREAM_SUCCESS_RESTORE(device->write(&iter.first), pos);
        StatusCode writeCode = writeMonitorElements(iter.second, device);
        if(writeCode != STATUS_CODE_SUCCESS) {
          device->seek(pos);
          return writeCode;
        }
      }
      return STATUS_CODE_SUCCESS;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename T>
    inline StatusCode MonitorElementStreamer::readMonitorElements(std::map<std::string,std::vector<std::shared_ptr<T>>> &elementMap, xdrstream::IODevice *device) {
      auto pos = device->getPosition();
      unsigned int nToRead = 0;
      XDRSTREAM_SUCCESS_RESTORE(device->read(&nToRead), pos);
      for(unsigned int i=0 ; i<nToRead ; ++i) {
        std::string key;
        XDRSTREAM_SUCCESS_RESTORE(device->read(&key), pos);
        std::vector<std::shared_ptr<T>> elements;
        StatusCode readCode = readMonitorElements(elements, device);
        if(readCode != STATUS_CODE_SUCCESS) {
          device->seek(pos);
          return readCode;
        }
        elementMap[key] = elements;
      }
      return STATUS_CODE_SUCCESS;
    }
    

  }
  
}

#endif //  DQM4HEP_MONITORELEMENTSTREAMER_H
