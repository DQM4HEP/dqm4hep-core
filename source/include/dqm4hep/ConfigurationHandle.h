/// \file ConfigurationHandle.h
/*
*
* ConfigurationHandle.h header template automatically generated by a class generator
* Creation date : mer. janv. 25 2017
*
* This file is part of DQM4HEP libraries.
*
* DQM4HEP is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* based upon these libraries are permitted. Any copy of these libraries
* must include this copyright notice.
*
* DQM4HEP is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
*
* @author Remi Ete
* @copyright CNRS , IPNL
*/


#ifndef CONFIGURATIONHANDLE_H
#define CONFIGURATIONHANDLE_H

#include "dqm4hep/DQM4HEP.h"
#include "dqm4hep/ParameterDirectory.h"
#include "dqm4hep/Parameters.h"
#include "dqm4hep/Parameter.h"

namespace dqm4hep {

  namespace core {

    class ParameterDirectory;

    /**
     * ConfigurationHandle class
     *
     * User interface to query parameters. The handle wraps
     * a parameter directory of the central configuration.
     * User can directly access to parameters in this directory
     * or to sub-directories. One can also create a new handle
     * for a sub directory using the createHandle(subDirName)
     * method.
     */
    class ConfigurationHandle
    {
      friend class ParameterDirectory;
      friend class ConfigurationManager;
    public:
      /**
       * Move constructor
       */
      ConfigurationHandle(ConfigurationHandle &&handle);

      /**
       * Destructor
       */
      ~ConfigurationHandle();

      /**
       * Printout all parameters
       *
       * @param recursive whether to printout all parameters recursively in all sub-directories
       */
      void ls(bool recursive = false) const;

      /**
       * Get the name of the wrapped directory
       */
      const std::string &getDirectoryName() const;

      /**
       * Get the full name of the wrapped directory
       */
      std::string getDirectoryFullName() const;

      /**
       * Whether the sub-directory exists. Sub-directory can have
       * the following form : 'dir' or 'dir/subDir/subSubDir'
       *
       * @param  dirName the subdirectory name
       */
      bool subDirectoryExists(const std::string &dirName) const;

      /**
       * Whether the target parameter exists in the wrapped directory
       *
       * @param  parName the parameter name
       */
      bool parameterExists(const std::string &parName) const;

      /**
       * Whether the target parameter exists in the sub-directory
       *
       * @param  subDirName the sub-directory name
       * @param  parName the parameter name
       */
      bool parameterExists(const std::string &subDirName, const std::string &parName) const;

      /**
       * Create a new handler using a sub-directory
       *
       * @param  subDirName the sub-directory name
       */
      ConfigurationHandle createHandle(const std::string &subDirName) const;

      /**
       * Get a parameter in the wrapped directory
       *
       * @param name the parameter name
       * @param parameter the parameter to receive
       */
      template <typename T>
      StatusCode getParameter(const std::string &name, Parameter<T> &parameter) const;

      /**
      * Get a parameter in the wrapped directory
      *
      * @param name the parameter name
      * @param parameter the parameter to receive
      * @param defaultValue the default value to assign if not found
       */
      template <typename T>
      StatusCode getParameter(const std::string &name, Parameter<T> &parameter, const T &defaultValue) const;

      /**
      * Get a parameter in the target sub-directory
      *
      * @param subDirName the sub-directory name
      * @param name the parameter name
      * @param parameter the parameter to receive
       */
      template <typename T>
      StatusCode getParameter(const std::string &subDirName, const std::string &name, Parameter<T> &parameter) const;

      /**
      * Get a parameter in the target sub-directory
      *
      * @param subDirName the sub-directory name
      * @param name the parameter name
      * @param parameter the parameter to receive
      * @param defaultValue the default value to assign if not found
       */
      template <typename T>
      StatusCode getParameter(const std::string &subDirName, const std::string &name, Parameter<T> &parameter, const T &defaultValue) const;

      /**
       * Get the list of sub-directories
       */
      StringVector getSubDirectorList() const;

      /**
       * Get the list of parameters in the wrapped directory
       */
      StringVector getParameterNames() const;

    private:
      /**
       * Constructor
       */
      ConfigurationHandle(ParameterDirectory *pDirectory);

    private:
      ParameterDirectory          *m_pDirectory;      ///< The wrapped parameter directory
    };

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    template <typename T>
    StatusCode ConfigurationHandle::getParameter(const std::string &name, Parameter<T> &parameter) const
    {
      parameter = m_pDirectory->getParameters().get<T>(name);

      if(!parameter.isInitialized())
        return STATUS_CODE_NOT_FOUND;

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    template <typename T>
    StatusCode ConfigurationHandle::getParameter(const std::string &name, Parameter<T> &parameter, const T &defaultValue) const
    {
      parameter = m_pDirectory->getParameters().get<T>(name, defaultValue);

      if(!parameter.isInitialized())
        return STATUS_CODE_FAILURE;

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    template <typename T>
    StatusCode ConfigurationHandle::getParameter(const std::string &subDirName, const std::string &name, Parameter<T> &parameter) const
    {
      ParameterDirectory *pDirectory = m_pDirectory->getSubDirectory(subDirName);

      if(nullptr == pDirectory)
        return STATUS_CODE_NOT_FOUND;

      parameter = pDirectory->getParameters().get<T>(name);

      if(!parameter.isInitialized())
        return STATUS_CODE_NOT_FOUND;

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    template <typename T>
    StatusCode ConfigurationHandle::getParameter(const std::string &subDirName, const std::string &name, Parameter<T> &parameter, const T &defaultValue) const
    {
      ParameterDirectory *pDirectory = m_pDirectory->getSubDirectory(subDirName);

      if(nullptr == pDirectory)
        return STATUS_CODE_NOT_FOUND;

      parameter = pDirectory->getParameters().get<T>(name, defaultValue);

      if(!parameter.isInitialized())
        return STATUS_CODE_NOT_FOUND;

      return STATUS_CODE_SUCCESS;
    }

  }

}

#endif  //  CONFIGURATIONHANDLE_H
