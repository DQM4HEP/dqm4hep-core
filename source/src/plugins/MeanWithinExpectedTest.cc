/// \file DQMQualityTest.cc
/*
 *
 * DQMQualityTest.cc source template automatically generated by a class generator
 * Creation date : ven. fï¿½vr. 20 2015
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include <dqm4hep/Internal.h>
#include <dqm4hep/Logging.h>
#include <dqm4hep/MonitorElement.h>
#include <dqm4hep/PluginManager.h>
#include <dqm4hep/QualityTest.h>
#include <dqm4hep/StatusCodes.h>
#include <dqm4hep/XmlHelper.h>
#include <dqm4hep/AnalysisHelper.h>

// -- root headers
#include <TH1.h>
#include <TMath.h>

namespace dqm4hep {

  namespace core {

    /** MeanWithinExpectedTest class
     */
    class MeanWithinExpectedTest : public QualityTest {
    public:
      class Factory : public QualityTestFactory {
      public:
        QTestPtr createQualityTest(const std::string &qname) const override;
      };

      MeanWithinExpectedTest(const std::string &name);
      ~MeanWithinExpectedTest() override = default;
      StatusCode readSettings(const dqm4hep::core::TiXmlHandle xmlHandle) override;
      void userRun(MonitorElement* monitorElement, QualityTestReport &report) override;

    protected:
      float m_expectedMean;
      float m_meanDeviationLower;
      float m_meanDeviationUpper;
      float m_percentage;
      std::vector<std::string> m_properties;

    };

    typedef MeanWithinExpectedTest::Factory MeanWithinExpectedTestFactory;

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    inline QTestPtr MeanWithinExpectedTest::Factory::createQualityTest(const std::string &qname) const {
      return std::shared_ptr<QTest>(new MeanWithinExpectedTest(qname));
    }

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    MeanWithinExpectedTest::MeanWithinExpectedTest(const std::string &qname)
        : QualityTest("MeanWithinExpected", qname),
          m_expectedMean(0.f),
	  m_meanDeviationLower(float NAN),
	  m_meanDeviationUpper(float NAN),
	  m_percentage(1.0),
	  m_properties()
{
      m_description = "Test if the mean of the histogram if contained in the expected user range. The quality is "
                      "defined as the probability to be close to mean : 1 at the mean, 0 infinitely far from the mean "
                      "(using TMath::Prob(chi2,1))";
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode MeanWithinExpectedTest::readSettings(const TiXmlHandle xmlHandle) {
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::readParameters(xmlHandle, "Properties", m_properties));

      RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::readParameter(xmlHandle, "ExpectedMean", m_expectedMean));
      RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::readParameter(xmlHandle, "Percentage", m_percentage));
      RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::readParameter(xmlHandle, "MeanDeviationLower", m_meanDeviationLower));
      RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::readParameter(xmlHandle, "MeanDeviationUpper", m_meanDeviationUpper,
												       [this](const float &value){return !(isnan(this->m_meanDeviationLower) && isnan(value));}));

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    void MeanWithinExpectedTest::userRun(MonitorElement* monitorElement, QualityTestReport &report) {
      
      TH1 *pHistogram = monitorElement->objectTo<TH1>();

      if (nullptr == pHistogram) {
        report.m_message = "ROOT monitor object is not a TH1 object !";
        throw StatusCodeException(STATUS_CODE_INVALID_PTR);
      }

      // For-loop code for doing multiple test types per qtest; use TBD
      /*
      for (std::vector<std::string>::iterator it = m_properties.begin(); it != m_properties.end(); it++
      {
        // Do something
      }
      */

      float result;

      if (m_properties[0] == "Mean")
	{
	  result = AnalysisHelper::mean(monitorElement, m_percentage);
	}
      else if (m_properties[0] == "Mean90")
	{
	  result = AnalysisHelper::mean90(monitorElement);
	}
      else if (m_properties[0] == "RMS")
	{
	  result = AnalysisHelper::rms(monitorElement, m_percentage);
	}
      else if (m_properties[0] == "RMS90")
	{
	  result = AnalysisHelper::rms90(monitorElement);
	}
      else if (m_properties[0] == "Median")
	{
	  result = AnalysisHelper::median(monitorElement);
	}
      else
	{
	  throw StatusCodeException(STATUS_CODE_FAILURE); // The generic error statuscode is temporary until a specific statuscode for this exists, or a custom error message can be written here
	}

      if ( std::isnan(m_meanDeviationLower) ) {
	// Do the lower-than comparison
	if (result < m_meanDeviationUpper) {
	  report.m_message = 
	    "Below expected value: expected " + typeToString(m_meanDeviationUpper) + ", got " + typeToString(result);
	  report.m_quality = 1.0;
	}
	else { 
	  report.m_message = 
	    "Above expected value: expected " + typeToString(m_meanDeviationUpper) + ", got " + typeToString(result);
	  report.m_quality = 0.0;
	}
      }
      else if ( std::isnan(m_meanDeviationUpper) ) {
	// Do the higher-than comparison
	if (result > m_meanDeviationLower) {
	  report.m_message = 
	    "Above expected value: expected " + typeToString(m_meanDeviationLower) + ", got " + typeToString(result);
	  report.m_quality = 1.0;
	}
	else { 
	  report.m_message = 
	    "Below expected value: expected " + typeToString(m_meanDeviationLower) + ", got " + typeToString(result);
	  report.m_quality = 0.0;
	}
      }
      else {
	// Do the within-range comparison
	const float range(fabs(m_meanDeviationUpper - m_meanDeviationLower));

	if (m_meanDeviationLower < result && result < m_meanDeviationUpper) {
	  report.m_message =
            "Within expected range: expected " + typeToString(m_expectedMean) + ", got " + typeToString(result);
	} 
	else {
	  report.m_message =
            "Out of expected range: expected " + typeToString(m_expectedMean) + ", got " + typeToString(result);
	}

	const float chi = (result - m_expectedMean) / range;
	report.m_quality = TMath::Prob(chi * chi, 1);
      }

    }

    DQM_PLUGIN_DECL(MeanWithinExpectedTestFactory, "MeanWithinExpectedTest");
  }
}
