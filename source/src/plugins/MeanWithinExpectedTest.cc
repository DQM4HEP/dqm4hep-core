/// \file DQMQualityTest.cc
/*
 *
 * DQMQualityTest.cc source template automatically generated by a class generator
 * Creation date : ven. fï¿½vr. 20 2015
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include <dqm4hep/Internal.h>
#include <dqm4hep/Logging.h>
#include <dqm4hep/MonitorElement.h>
#include <dqm4hep/PluginManager.h>
#include <dqm4hep/QualityTest.h>
#include <dqm4hep/StatusCodes.h>
#include <dqm4hep/XmlHelper.h>
#include <dqm4hep/AnalysisHelper.h>
//#include <dqm4hep/AnalysisHelper.cc>

// -- root headers
#include <TH1.h>
#include <TMath.h>

namespace dqm4hep {

  namespace core {

    /** MeanWithinExpectedTest class
     */
    class MeanWithinExpectedTest : public QualityTest {
    public:
      class Factory : public QualityTestFactory {
      public:
        QTestPtr createQualityTest(const std::string &qname) const override;
      };

      MeanWithinExpectedTest(const std::string &name);
      ~MeanWithinExpectedTest() override = default;
      StatusCode readSettings(const dqm4hep::core::TiXmlHandle xmlHandle) override;
      void userRun(MonitorElement* monitorElement, QualityTestReport &report) override;

    protected:
      float m_expectedMean;
      float m_meanDeviationLower;
      float m_meanDeviationUpper;
      int   m_testType;
      float m_percentage;
    };

    typedef MeanWithinExpectedTest::Factory MeanWithinExpectedTestFactory;

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    inline QTestPtr MeanWithinExpectedTest::Factory::createQualityTest(const std::string &qname) const {
      return std::shared_ptr<QTest>(new MeanWithinExpectedTest(qname));
    }

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    MeanWithinExpectedTest::MeanWithinExpectedTest(const std::string &qname)
        : QualityTest("MeanWithinExpected", qname),
          m_expectedMean(0.f),
          m_meanDeviationLower(0.f),
          m_meanDeviationUpper(0.f),
	  m_testType(0),
	  m_percentage(0.f){
      m_description = "Test if the mean of the histogram if contained in the expected user range. The quality is "
                      "defined as the probability to be close to mean : 1 at the mean, 0 infinitely far from the mean "
                      "(using TMath::Prob(chi2,1))";
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode MeanWithinExpectedTest::readSettings(const TiXmlHandle xmlHandle) {
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::readParameter(xmlHandle, "ExpectedMean", m_expectedMean));

      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=,
                       XmlHelper::readParameter(xmlHandle, "MeanDeviationLower", m_meanDeviationLower,
                                                [this](const float &value) { return value < this->m_expectedMean; }));

      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=,
                       XmlHelper::readParameter(xmlHandle, "MeanDeviationUpper", m_meanDeviationUpper,
                                                [this](const float &value) { return value > this->m_expectedMean; }));

      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::readParameter(xmlHandle, "TestType", m_testType));

      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::readParameter(xmlHandle, "Percentage", m_percentage));

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    void MeanWithinExpectedTest::userRun(MonitorElement* monitorElement, QualityTestReport &report) {
      TH1 *pHistogram = monitorElement->objectTo<TH1>();

      if (nullptr == pHistogram) {
        report.m_message = "ROOT monitor object is not a TH1 object !";
        throw StatusCodeException(STATUS_CODE_INVALID_PTR);
      }

      //const float mean(pHistogram->GetMean());
      float mean = AnalysisHelper::mainHelper(monitorElement, m_testType, m_percentage);
      const float range(fabs(m_meanDeviationUpper - m_meanDeviationLower));

      if (m_meanDeviationLower < mean && mean < m_meanDeviationUpper) {
        report.m_message =
            "Within expected range: expected " + typeToString(m_expectedMean) + ", got " + typeToString(mean);
      } 
      else {
        report.m_message =
            "Out of expected range: expected " + typeToString(m_expectedMean) + ", got " + typeToString(mean);
      }

      const float chi = (mean - m_expectedMean) / range;
      report.m_quality = TMath::Prob(chi * chi, 1);
    }

    DQM_PLUGIN_DECL(MeanWithinExpectedTestFactory, "MeanWithinExpectedTest");
  }
}
