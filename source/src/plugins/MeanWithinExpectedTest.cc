/// \file DQMQualityTest.cc
/*
 *
 * DQMQualityTest.cc source template automatically generated by a class generator
 * Creation date : ven. fï¿½vr. 20 2015
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include <dqm4hep/Internal.h>
#include <dqm4hep/Logging.h>
#include <dqm4hep/MonitorElement.h>
#include <dqm4hep/PluginManager.h>
#include <dqm4hep/QualityTest.h>
#include <dqm4hep/StatusCodes.h>
#include <dqm4hep/XmlHelper.h>
#include <dqm4hep/AnalysisHelper.h>
//#include <dqm4hep/AnalysisHelper.cc>

// -- root headers
#include <TH1.h>
#include <TMath.h>

namespace dqm4hep {

  namespace core {

    /** MeanWithinExpectedTest class
     */
    class MeanWithinExpectedTest : public QualityTest {
    public:
      class Factory : public QualityTestFactory {
      public:
        QTestPtr createQualityTest(const std::string &qname) const override;
      };

      MeanWithinExpectedTest(const std::string &name);
      ~MeanWithinExpectedTest() override = default;
      StatusCode readSettings(const dqm4hep::core::TiXmlHandle xmlHandle) override;
      void userRun(MonitorElement* monitorElement, QualityTestReport &report) override;

    protected:
      float m_expectedMean;
      float m_meanDeviationLower;
      float m_meanDeviationUpper;
      float m_percentage;

      std::vector<std::string> m_testTypesList;

    };

    typedef MeanWithinExpectedTest::Factory MeanWithinExpectedTestFactory;

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    inline QTestPtr MeanWithinExpectedTest::Factory::createQualityTest(const std::string &qname) const {
      return std::shared_ptr<QTest>(new MeanWithinExpectedTest(qname));
    }

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    MeanWithinExpectedTest::MeanWithinExpectedTest(const std::string &qname)
        : QualityTest("MeanWithinExpected", qname),
          m_expectedMean(0.f),
          m_meanDeviationLower(0.f),
          m_meanDeviationUpper(0.f),
	  m_percentage(1.0)
{
      m_description = "Test if the mean of the histogram if contained in the expected user range. The quality is "
                      "defined as the probability to be close to mean : 1 at the mean, 0 infinitely far from the mean "
                      "(using TMath::Prob(chi2,1))";
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode MeanWithinExpectedTest::readSettings(const TiXmlHandle xmlHandle) {
      //RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::readParameter(xmlHandle, "ExpectedMean", m_expectedMean));
      //RETURN_RESULT_IF(STATUS_CODE_NOT_FOUND, !=, XmlHelper::readParameter(xmlHandle, "ExpectedMean", m_expectedMean));
      SOFT_RETURN_RESULT_IF(XmlHelper::readParameter(xmlHandle, "ExpectedMean", m_expectedMean));
      //XmlHelper::readParameter(xmlHandle, "ExpectedMean", m_expectedMean);
      
      // Okay so the below code is the readParameter function with the optional validator to check the result;
      // the code below fails when the ExpectedMean isn't found, because the given lower bound is above the mean,
      // because it defaults to 0. This behaviour is good, but doesn't reveal itself very well when run, giving
      // cryptic error messages that don't explain what went wrong.

      // It can easily be removed, but this will result in some strange behavior further down when we actually
      // solve for the mean. Ideally, we throw an error and include a message explaining that the bound is too
      // high or too low, and to check the XML file to fix it.

      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=,
                       XmlHelper::readParameter(xmlHandle, "MeanDeviationLower", m_meanDeviationLower,
                                                [this](const float &value) { return value < this->m_expectedMean; }));

      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=,
                       XmlHelper::readParameter(xmlHandle, "MeanDeviationUpper", m_meanDeviationUpper,
                                                [this](const float &value) { return value > this->m_expectedMean; }));

      // This only succeeds if there's no percentage -- so we need to use the SOFT version I think?
      SOFT_RETURN_RESULT_IF(XmlHelper::readParameter(xmlHandle, "Percentage", m_percentage));

      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::readParameters(xmlHandle, "TestTypeList", m_testTypesList));

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    void MeanWithinExpectedTest::userRun(MonitorElement* monitorElement, QualityTestReport &report) {
      TH1 *pHistogram = monitorElement->objectTo<TH1>();

      if (nullptr == pHistogram) {
        report.m_message = "ROOT monitor object is not a TH1 object !";
        throw StatusCodeException(STATUS_CODE_INVALID_PTR);
      }

      const float range(fabs(m_meanDeviationUpper - m_meanDeviationLower));
      float result;

      for (std::vector<std::string>::iterator it = m_testTypesList.begin(); it != m_testTypesList.end(); it++){

	result = AnalysisHelper::mainHelper(monitorElement, *it, m_percentage);
      }

      if (m_meanDeviationLower < result && result < m_meanDeviationUpper) {
        report.m_message =
            "Within expected range: expected " + typeToString(m_expectedMean) + ", got " + typeToString(result);
      } 
      else {
        report.m_message =
            "Out of expected range: expected " + typeToString(m_expectedMean) + ", got " + typeToString(result);
      }

      const float chi = (result - m_expectedMean) / range;
      report.m_quality = TMath::Prob(chi * chi, 1);
    }

    DQM_PLUGIN_DECL(MeanWithinExpectedTestFactory, "MeanWithinExpectedTest");
  }
}
