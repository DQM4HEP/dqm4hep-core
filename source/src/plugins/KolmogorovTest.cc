/// \file DQMQualityTest.cc
/*
 *
 * DQMQualityTest.cc source template automatically generated by a class generator
 * Creation date : ven. fï¿½vr. 20 2015
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include <dqm4hep/Internal.h>
#include <dqm4hep/Logging.h>
#include <dqm4hep/MonitorElement.h>
#include <dqm4hep/PluginManager.h>
#include <dqm4hep/QualityTest.h>
#include <dqm4hep/StatusCodes.h>
#include <dqm4hep/XmlHelper.h>
#include <dqm4hep/AnalysisHelper.h>

// -- root headers
#include <TH1.h>
#include <TMath.h>

namespace dqm4hep {

  namespace core {

    /** KolmogorovTest class
     */
    class KolmogorovTest : public QualityTest {
    public:
      class Factory : public QualityTestFactory {
      public:
        QTestPtr createQualityTest(const std::string &qname) const override;
      };

      KolmogorovTest(const std::string &name);
      ~KolmogorovTest() override = default;
      StatusCode readSettings(const dqm4hep::core::TiXmlHandle xmlHandle) override;
      void userRun(MonitorElement* monitorElement, QualityTestReport &report) override;

    protected:
      std::string m_options;

    };

    typedef KolmogorovTest::Factory KolmogorovTestFactory;

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    inline QTestPtr KolmogorovTest::Factory::createQualityTest(const std::string &qname) const {
      return std::shared_ptr<QTest>(new KolmogorovTest(qname));
    }

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    KolmogorovTest::KolmogorovTest(const std::string &qname)
        : QualityTest("Kolmogorov", qname),
	  m_options()
{
      m_description = "Performs the Kolmogorov-Smirnov test on a monitor element and a reference, outputting the p-value. In general this should only "
	              "be used for TGraphs. While this test can take TH1s, the Kolmogorov test is intended for use on unbinned data, not histograms. "
	              "See https://root.cern.ch/doc/master/classTH1.html#aeadcf087afe6ba203bcde124cfabbee4 for more information.";
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode KolmogorovTest::readSettings(const TiXmlHandle xmlHandle) {
      RETURN_RESULT_IF_AND_IF(STATUS_CODE_SUCCESS, STATUS_CODE_NOT_FOUND, !=, XmlHelper::readParameter(xmlHandle, "Options", m_options));

      return STATUS_CODE_SUCCESS;
    }

    void KolmogorovTest::userRun(MonitorElement* pMonitorElement, QualityTestReport &report) {
      const bool hasObject = (pMonitorElement->object() != nullptr);
      const bool hasReference = (pMonitorElement->reference() != nullptr);
      const bool isHistogram = pMonitorElement->object()->InheritsFrom("TH1");
      const bool isGraph = pMonitorElement->object()->InheritsFrom("TGraph");

      if (!hasObject) {
        report.m_message = "No object attached to monitor element";
        report.m_quality = 0.f;
        throw StatusCodeException(STATUS_CODE_INVALID_PTR);
      }

      if (!hasReference) {
        report.m_message = "No reference attached to monitor element";
        report.m_quality = 0.f;
        throw StatusCodeException(STATUS_CODE_INVALID_PTR);
      }

      if (isGraph) {
	TGraph* pGraph = pMonitorElement->objectTo<TGraph>();
	TGraph* pReferenceGraph = pMonitorElement->referenceTo<TGraph>();

	Option_t* pOptions = &m_options[0u];

	int sizeGraph = pGraph->GetN();
	int sizeRef = pReferenceGraph->GetN()  ;
	double* pArrayGraph = pGraph->GetY();
	double* pArrayRef = pReferenceGraph->GetY();

	std::sort(&pArrayGraph[0], &pArrayGraph[sizeGraph]);
	std::sort(&pArrayRef[0], &pArrayRef[sizeRef]);
       
	report.m_message = ("Options used: " + m_options);
	report.m_quality = TMath::KolmogorovTest(sizeGraph, pArrayGraph, sizeRef, pArrayRef, pOptions);
      }
      else if (isHistogram) {
	TH1* pHistogram = pMonitorElement->objectTo<TH1>();
	TH1* pReferenceHistogram = pMonitorElement->referenceTo<TH1>();
	
	if (m_options == "") {
	  m_options += "UO";
	}
	Option_t* pOptions = &m_options[0u];
	
	report.m_message = ("NB: the Kolmogorov test is not intended for histograms! Use caution when interepreting the quality. Options used: " + m_options);
	report.m_quality = pHistogram->KolmogorovTest(pReferenceHistogram, pOptions);
      }
      else {
	report.m_message = "ROOT monitor element object is of unrecognised type!";
        report.m_quality = 0.f;
	throw StatusCodeException(STATUS_CODE_INVALID_PTR);
      }

    }
    
    DQM_PLUGIN_DECL(KolmogorovTestFactory, "KolmogorovTest");
  }
}
