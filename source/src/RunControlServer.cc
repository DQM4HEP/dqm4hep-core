/// \file RunControlServer.cc
/*
*
* RunControlServer.cc source template automatically generated by a class generator
* Creation date : lun. janv. 23 2017
*
* This file is part of DQM4HEP libraries.
*
* DQM4HEP is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* based upon these libraries are permitted. Any copy of these libraries
* must include this copyright notice.
*
* DQM4HEP is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
*
* @author Remi Ete
* @copyright CNRS , IPNL
*/


#include "dqm4hep/RunControlServer.h"
#include "dqm4hep/NetworkTool.h"

namespace dqm4hep {

  namespace core {

    RunControlServer::RunControlServer(const std::string &name) :
      m_pRunControlInterface(nullptr)
    {
      // the server
      m_pServer = new net::Server(name);

      // create services and request handlers
      m_pRunService = Network::Server::createRCActionService(m_pServer, m_pServer->name());

      Network::Server::createRCRunInfoRequestHandler(m_pServer, m_pServer->name(), this, &RunControlServer::handleRunInfoRequest);

      // the run control
      m_pRunControl = new RunControl(name);
      m_pRunControl->onStartOfRun().connect(this, &RunControlServer::startNewRunSignal);
      m_pRunControl->onEndOfRun().connect(this, &RunControlServer::endCurrentRunSignal);
    }

    //-------------------------------------------------------------------------------------------------

    RunControlServer::~RunControlServer()
    {
      this->stop();

      delete m_pServer;
      delete m_pRunControl;

      if(m_pRunControlInterface)
        delete m_pRunControlInterface;
    }

    //-------------------------------------------------------------------------------------------------

    void RunControlServer::start()
    {
      if(this->isRunning())
        return;

      m_pServer->start();

      if(m_pRunControlInterface)
        m_pRunControlInterface->onServerStartup();
    }

    //-------------------------------------------------------------------------------------------------

    void RunControlServer::stop()
    {
      if(!this->isRunning())
        return;

      m_pServer->stop();

      if(m_pRunControlInterface)
        m_pRunControlInterface->onServerShutdown();
    }

    //-------------------------------------------------------------------------------------------------

    bool RunControlServer::isRunning() const
    {
      return m_pServer->isRunning();
    }

    //-------------------------------------------------------------------------------------------------

    void RunControlServer::setRunControlInterface(RunControlInterface *pRunControlInterface)
    {
      if(nullptr == pRunControlInterface)
        return;

      if(nullptr != m_pRunControlInterface && m_pRunControlInterface != pRunControlInterface)
        delete m_pRunControlInterface;

      m_pRunControlInterface = pRunControlInterface;
      m_pRunControlInterface->setRunControl(m_pRunControl);
    }

    //-------------------------------------------------------------------------------------------------

    void RunControlServer::handleRunInfoRequest(const Json::Value &/*request*/, Json::Value &response)
    {
      response["state"] = static_cast<int>(m_pRunControl->runState());
      response["runcontrol"] = m_pRunControl->name();

      Json::Value runValue;
      this->runToJson(m_pRunControl->run(), runValue);

      response["run"] = runValue;
    }

    //-------------------------------------------------------------------------------------------------

    void RunControlServer::runToJson(const Run &run, Json::Value &value)
    {
      value["number"] = run.runNumber();
      value["start"] = int64_t(std::chrono::system_clock::to_time_t(run.startTime()));
      value["end"] = int64_t(std::chrono::system_clock::to_time_t(run.endTime()));
      value["detector"] = run.detectorName();
      value["description"] = run.description();

      Json::Value runParameters;
      const StringVector runParameterKeys(run.parameterKeys());

      for(auto iter = runParameterKeys.begin(), endIter = runParameterKeys.end() ; endIter != iter ; ++iter)
      {
        std::string parameterValue;
        run.parameter(*iter, parameterValue);
        runParameters[*iter] = parameterValue;
      }

      value["parameters"] = runParameters;
    }

    //-------------------------------------------------------------------------------------------------

    void RunControlServer::startNewRunSignal(const Run &run)
    {
      Json::Value runActionValue;
      runActionValue["action"] = "start";
      runActionValue["runcontrol"] = m_pRunControl->name();

      Json::Value runValue;
      this->runToJson(run, runValue);
      runActionValue["run"] = runValue;

      m_pRunService->update(runActionValue);
    }

    //-------------------------------------------------------------------------------------------------

    void RunControlServer::endCurrentRunSignal()
    {
      Json::Value runActionValue;
      runActionValue["action"] = "stop";
      runActionValue["runcontrol"] = m_pRunControl->name();

      Json::Value runValue;
      this->runToJson(m_pRunControl->run(), runValue);
      runActionValue["run"] = runValue;

      m_pRunService->update(runActionValue);
    }

  }

}
