/*
 *
 * PluginManager.cc source template automatically generated by a class generator
 * Creation date : lun. aoï¿½t 17 2015
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include <dqm4hep/Logging.h>
#include <dqm4hep/PluginManager.h>

// -- std headers
#include <cstdlib>
#include <dlfcn.h>

namespace dqm4hep {

  namespace core {

    PluginManager::PluginManager() {
      /* nop */
    }

    //-------------------------------------------------------------------------------------------------

    PluginManager::~PluginManager() {
      for (PluginMap::const_iterator iter = m_pluginMap.begin(), endIter = m_pluginMap.end(); endIter != iter; ++iter) {
        delete iter->second;
      }

      m_pluginMap.clear();
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode PluginManager::loadLibraries() {
      // get the environment plug-in dll variable
      char *pPluginDllEnv = getenv("DQM4HEP_PLUGIN_DLL");

      if (pPluginDllEnv == nullptr) {
        dqm_debug("Environment variable DQM4HEP_PLUGIN_DLL not found ! \n"
                  "Set it before loading shared libraries. \n"
                  "Example : export DQM4HEP_PLUGIN_DLL=libPlugin1.so:libPlugin2.so");

        return STATUS_CODE_SUCCESS;
      }

      // split the string into a list
      std::string libraryConcatenateList(pPluginDllEnv);
      StringVector libraryList;

      dqm4hep::core::tokenize(libraryConcatenateList, libraryList, ":");

      // load the shared libraries
      return this->loadLibraries(libraryList);
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode PluginManager::loadLibraries(const StringVector &libraryNameList) {
      for (auto iter = libraryNameList.begin(), endIter = libraryNameList.end(); endIter != iter; ++iter) {
        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->loadLibrary(*iter));
      }

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode PluginManager::loadLibrary(const std::string &libraryName) {
      size_t idx = libraryName.find_last_of("/");

      // the library basename, i.e. /path/to/libBlah.so --> libBlah.so
      std::string libBaseName(libraryName.substr(idx + 1));

      char *real_path = realpath(libraryName.c_str(), nullptr);

      if (nullptr != real_path) {
        dqm_info("<!-- Loading shared library : {0} ({1})-->", real_path, libBaseName);

        // use real_path
        free(real_path);
      } else {
        dqm_info("<!-- Loading shared library : {0} ({1})-->", libraryName, libBaseName);
      }

      void *pLibPointer = dlopen(libraryName.c_str(), RTLD_LAZY | RTLD_GLOBAL);

      if (pLibPointer == nullptr) {
        dqm_error("<!-- ERROR loading shared library : {0}\n    ->    {1} -->", libraryName, dlerror());
        return STATUS_CODE_FAILURE;
      }

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    const Plugin *PluginManager::getPlugin(const std::string &pluginName) const {
      if (!isPluginRegistered(pluginName))
        return nullptr;

      return m_pluginMap.find(pluginName)->second;
    }

    //-------------------------------------------------------------------------------------------------

    bool PluginManager::isPluginRegistered(const std::string &pluginName) const {
      return (m_pluginMap.find(pluginName) != m_pluginMap.end());
    }

    //-------------------------------------------------------------------------------------------------

    StringVector PluginManager::pluginNames() const {
      StringVector pluginNameList;

      for (auto iter = m_pluginMap.begin(), endIter = m_pluginMap.end(); endIter != iter; ++iter) {
        pluginNameList.push_back(iter->first);
      }

      return pluginNameList;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode PluginManager::registerPlugin(Plugin *pPlugin) {
      // null ptr case
      if (nullptr == pPlugin)
        return STATUS_CODE_INVALID_PTR;

      // check if the plug is already registered
      if (isPluginRegistered(pPlugin->pluginName())) {
        delete pPlugin;
        pPlugin = nullptr;
        return STATUS_CODE_ALREADY_PRESENT;
      }

      // try to register it
      if (!m_pluginMap.insert(PluginMap::value_type(pPlugin->pluginName(), pPlugin)).second) {
        delete pPlugin;
        pPlugin = nullptr;

        return STATUS_CODE_FAILURE;
      }

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    void PluginManager::dump() const {
      dqm_info("******************************************************");
      dqm_info("******** Plugin manager -- Registered plugins ********");
      for (auto plugin : m_pluginMap) {
        dqm_info("** Plugin [class={0}] : {1}", plugin.second->pluginName(), plugin.second->className());
      }
      dqm_info("******************************************************");
    }
  }
}
