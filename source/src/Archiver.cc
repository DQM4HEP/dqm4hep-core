/// \file Archiver.cc
/*
 *
 * Archiver.cc source template automatically generated by a class generator
 * Creation date : mar. oct. 7 2014
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/Archiver.h"
#include "dqm4hep/Directory.h"
#include "dqm4hep/Logging.h"
#include "dqm4hep/MonitorElement.h"
#include "dqm4hep/Storage.h"

// -- root headers
#include "TDirectory.h"
#include "TFile.h"
#include "TSystem.h"

namespace dqm4hep {

  namespace core {

    Archiver::Archiver() : m_fileName(""), m_openingMode(""), m_pArchiveFile(nullptr), m_isOpened(false) {
      /* nop */
    }

    //-------------------------------------------------------------------------------------------------

    Archiver::Archiver(const std::string &archiveFileName, const std::string &openingMode, bool allowSuffix) {
      THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->open(archiveFileName, openingMode, allowSuffix));
    }

    //-------------------------------------------------------------------------------------------------

    Archiver::~Archiver() {
      if (m_isOpened)
        close();
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Archiver::open(const std::string &archiveFileName, const std::string &openingMode, bool allowSuffix) {
      // if already open write the archive if not done
      // and close it before to re-open
      if (m_isOpened)
        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, close());

      if (archiveFileName.empty())
        return STATUS_CODE_INVALID_PARAMETER;

      if (allowSuffix) {
        int fileId(0);

        size_t pos = archiveFileName.rfind(".root");

        if (std::string::npos == pos) {
          dqm_error("Couldn't open archive '{0}' ! Must be a root file !", archiveFileName);
          return STATUS_CODE_INVALID_PARAMETER;
        }

        std::string baseArchiveName = archiveFileName.substr(0, pos);
        std::string fullArchiveName = archiveFileName;

        while (!gSystem->AccessPathName(fullArchiveName.c_str())) {
          std::stringstream ss;
          ss << baseArchiveName << "_" << fileId << ".root";
          fullArchiveName = ss.str();
          fileId++;
        }

        m_fileName = fullArchiveName;
      } else {
        m_fileName = archiveFileName;
      }

      m_openingMode = openingMode;

      dqm_info("Archiver::open: Opening archive {0}", m_fileName);

      m_pArchiveFile = new TFile(m_fileName.c_str(), openingMode.c_str());

      if (nullptr == m_pArchiveFile) {
        dqm_error("Couldn't open archive '{0}' !", m_fileName);
        return STATUS_CODE_FAILURE;
      }

      m_isOpened = true;

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Archiver::close() {
      if (!m_isOpened)
        return STATUS_CODE_FAILURE;

      m_pArchiveFile->Close();
      delete m_pArchiveFile;

      m_pArchiveFile = nullptr;

      m_isOpened = false;
      m_openingMode = "";

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Archiver::archive(MeStoragePtr storage, const std::string &dirName) {
      if (!this->isOpened())
        return STATUS_CODE_NOT_ALLOWED;

      TDirectory *pDirectory(nullptr);

      if (!dirName.empty()) {
        pDirectory = m_pArchiveFile->mkdir(dirName.c_str());

        if (pDirectory == nullptr)
          return STATUS_CODE_FAILURE;
      } else {
        // TFile inherits from TDirectory ...
        pDirectory = m_pArchiveFile;
      }

      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, recursiveFill(storage->root(), pDirectory));

      m_pArchiveFile->cd();
      m_pArchiveFile->Write();

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    const std::string &Archiver::getFileName() const {
      return m_fileName;
    }

    //-------------------------------------------------------------------------------------------------

    bool Archiver::isOpened() const {
      return m_isOpened;
    }

    //-------------------------------------------------------------------------------------------------

    const std::string &Archiver::getOpeningMode() const {
      return m_openingMode;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Archiver::recursiveFill(MonitorElementDir directory, TDirectory *pROOTDir) {
      if (nullptr == directory || nullptr == pROOTDir)
        return STATUS_CODE_INVALID_PTR;

      pROOTDir->cd();

      const auto &subDirList(directory->subdirs());

      if (!subDirList.empty()) {
        for (auto iter = subDirList.begin(), endIter = subDirList.end(); endIter != iter; ++iter) {
          auto subDir = *iter;
          TDirectory *pROOTSubDir = pROOTDir->mkdir(subDir->name().c_str());

          if (nullptr != pROOTSubDir) {
            RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, Archiver::recursiveFill(subDir, pROOTSubDir));
          }
        }
      }

      // write the monitor elements
      if (!directory->isEmpty()) {
        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, Archiver::writeMonitorElements(directory, pROOTDir));
      }

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Archiver::writeMonitorElements(MonitorElementDir directory, TDirectory *pROOTDir) {
      if (nullptr == directory || nullptr == pROOTDir)
        return STATUS_CODE_INVALID_PTR;

      pROOTDir->cd();

      const auto &monitorElementList(directory->contents());

      for (auto iter = monitorElementList.begin(), endIter = monitorElementList.end(); endIter != iter; ++iter) {
        TObject *pObject = (*iter)->object();
        pROOTDir->WriteObjectAny(pObject, pObject->IsA(), (*iter)->name().c_str());
      }

      return STATUS_CODE_SUCCESS;
    }
  }
}
