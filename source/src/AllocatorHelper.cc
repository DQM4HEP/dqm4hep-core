/// \file AllocatorHelper.cc
/*
 *
 * AllocatorHelper.cc source template automatically generated by a class generator
 * Creation date : mer. janv. 6 2016
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright
 */

// -- dqm4hep headers
#include <dqm4hep/AllocatorHelper.h>
#include <dqm4hep/XmlHelper.h>
#include <dqm4hep/MonitorElement.h>

#include <TH1.h>
#include <TH2.h>
#include <TH3.h>
#include <TProfile.h>
#include <TProfile2D.h>
#include <TClass.h>

namespace dqm4hep {

  namespace core {
    
    TObject* DefaultXMLAllocator::create(TiXmlElement *element) const {
      if(nullptr == element) {
        return nullptr;
      }
      std::string className;
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "type", className)) {
        return nullptr;
      }
      TClass* cls = TClass::GetClass(className.c_str());
      if(nullptr == cls) {
        return nullptr;
      }
      TObject* object = (TObject*)cls->New();
      return object;
    }
    
    //-------------------------------------------------------------------------------------------------

    TObject* TH1XMLAllocator::create(TiXmlElement *element) const {
      if(nullptr == element) {
        return nullptr;
      }
      std::string name, title, className;
      int nBins = 0;
      float minValue = 0.f, maxValue = 0.f;
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "nBins", nBins)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "min", minValue)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "max", maxValue)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "name", name)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "title", title)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "type", className)) {
        return nullptr;
      }
      if(className == "TH1D") {
        TH1DAllocator allocator;
        return allocator.create(name.c_str(), title.c_str(), nBins, minValue, maxValue);
      }
      else if(className == "TH1F") {
        TH1FAllocator allocator;
        return allocator.create(name.c_str(), title.c_str(), nBins, minValue, maxValue);
      }
      else if(className == "TH1I") {
        TH1IAllocator allocator;
        return allocator.create(name.c_str(), title.c_str(), nBins, minValue, maxValue);
      }
      else if(className == "TH1C") {
        TH1CAllocator allocator;
        return allocator.create(name.c_str(), title.c_str(), nBins, minValue, maxValue);
      }
      else if(className == "TH1S") {
        TH1SAllocator allocator;
        return allocator.create(name.c_str(), title.c_str(), nBins, minValue, maxValue);
      }
      return nullptr;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    TObject* TH2XMLAllocator::create(TiXmlElement *element) const {
      if(nullptr == element) {
        return nullptr;
      }
      std::string name, title, className;
      int nBinsX = 0, nBinsY = 0;
      float minValueX = 0.f, maxValueX = 0.f, minValueY = 0.f, maxValueY = 0.f;
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "nBinsX", nBinsX)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "minX", minValueX)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "maxX", maxValueX)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "nBinsY", nBinsY)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "minY", minValueY)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "maxY", maxValueY)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "name", name)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "title", title)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "type", className)) {
        return nullptr;
      }
      if(className == "TH2D") {
        TH2DAllocator allocator;
        return allocator.create(name.c_str(), title.c_str(), nBinsX, minValueX, maxValueX, nBinsY, minValueY, maxValueY);
      }
      else if(className == "TH2F") {
        TH2FAllocator allocator;
        return allocator.create(name.c_str(), title.c_str(), nBinsX, minValueX, maxValueX, nBinsY, minValueY, maxValueY);
      }
      else if(className == "TH2I") {
        TH2IAllocator allocator;
        return allocator.create(name.c_str(), title.c_str(), nBinsX, minValueX, maxValueX, nBinsY, minValueY, maxValueY);
      }
      else if(className == "TH2C") {
        TH2CAllocator allocator;
        return allocator.create(name.c_str(), title.c_str(), nBinsX, minValueX, maxValueX, nBinsY, minValueY, maxValueY);
      }
      else if(className == "TH2S") {
        TH2SAllocator allocator;
        return allocator.create(name.c_str(), title.c_str(), nBinsX, minValueX, maxValueX, nBinsY, minValueY, maxValueY);
      }
      return nullptr;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    TObject* TH3XMLAllocator::create(TiXmlElement *element) const {
      if(nullptr == element) {
        return nullptr;
      }
      std::string name, title, className;
      int nBinsX = 0, nBinsY = 0, nBinsZ = 0;
      float minValueX = 0.f, maxValueX = 0.f, minValueY = 0.f, maxValueY = 0.f, minValueZ = 0.f, maxValueZ = 0.f;
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "nBinsX", nBinsX)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "minX", minValueX)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "maxX", maxValueX)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "nBinsY", nBinsY)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "minY", minValueY)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "maxY", maxValueY)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "nBinsZ", nBinsZ)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "minZ", minValueZ)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "maxZ", maxValueZ)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "name", name)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "title", title)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "type", className)) {
        return nullptr;
      }
      if(className == "TH3D") {
        TH3DAllocator allocator;
        return allocator.create(name.c_str(), title.c_str(), nBinsX, minValueX, maxValueX, nBinsY, minValueY, maxValueY, nBinsZ, minValueZ, maxValueZ);
      }
      else if(className == "TH3F") {
        TH3FAllocator allocator;
        return allocator.create(name.c_str(), title.c_str(), nBinsX, minValueX, maxValueX, nBinsY, minValueY, maxValueY, nBinsZ, minValueZ, maxValueZ);
      }
      else if(className == "TH3I") {
        TH3IAllocator allocator;
        return allocator.create(name.c_str(), title.c_str(), nBinsX, minValueX, maxValueX, nBinsY, minValueY, maxValueY, nBinsZ, minValueZ, maxValueZ);
      }
      else if(className == "TH3C") {
        TH3CAllocator allocator;
        return allocator.create(name.c_str(), title.c_str(), nBinsX, minValueX, maxValueX, nBinsY, minValueY, maxValueY, nBinsZ, minValueZ, maxValueZ);
      }
      else if(className == "TH3S") {
        TH3SAllocator allocator;
        return allocator.create(name.c_str(), title.c_str(), nBinsX, minValueX, maxValueX, nBinsY, minValueY, maxValueY, nBinsZ, minValueZ, maxValueZ);
      }
      return nullptr;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    TObject* TScalarXMLAllocator::create(TiXmlElement *element) const {
      if(nullptr == element) {
        return nullptr;
      }
      std::string className, value;
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "type", className)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "value", value)) {
        return nullptr;
      }
      if(className == "int") {
        TScalarIntAllocator allocator;
        int typeValue = 0;
        stringToType(value, typeValue);
        return allocator.create(typeValue);
      }
      else if(className == "real" || className == "float") {
        TScalarFloatAllocator allocator;
        float typeValue = 0;
        stringToType(value, typeValue);
        return allocator.create(typeValue);
      }
      else if(className == "double") {
        TScalarDoubleAllocator allocator;
        double typeValue = 0;
        stringToType(value, typeValue);
        return allocator.create(typeValue);
      }
      else if(className == "short") {
        TScalarShortAllocator allocator;
        short typeValue = 0;
        stringToType(value, typeValue);
        return allocator.create(typeValue);
      }
      else if(className == "long") {
        TScalarLongAllocator allocator;
        long typeValue = 0;
        stringToType(value, typeValue);
        return allocator.create(typeValue);
      }
      else if(className == "long64") {
        TScalarLong64Allocator allocator;
        Long64_t typeValue = 0;
        stringToType(value, typeValue);
        return allocator.create(typeValue);
      }
      return nullptr;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    TObject* THStackXMLAllocator::create(TiXmlElement *element) const {
      if(nullptr == element) {
        return nullptr;
      }
      std::string name, title;
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "name", name)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "title", title)) {
        return nullptr;
      }
      THStackAllocator allocator;
      return allocator.create(name.c_str(), title.c_str());      
    }
    
    //-------------------------------------------------------------------------------------------------
    
    TObject* TH2PolyXMLAllocator::create(TiXmlElement *element) const {
      if(nullptr == element) {
        return nullptr;
      }
      std::string name, title;
      double xlow = 0, xup = 0, ylow = 0, yup = 0;
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "xlow", xlow)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "xup", xup)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "ylow", ylow)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "yup", yup)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "name", name)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "title", title)) {
        return nullptr;
      }
      TH2PolyAllocator allocator;
      return allocator.create(name.c_str(), title.c_str(), xlow, xup, ylow, yup);
    }
    
    //-------------------------------------------------------------------------------------------------
    
    TObject* TProfileXMLAllocator::create(TiXmlElement *element) const {
      if(nullptr == element) {
        return nullptr;
      }
      std::string name, title;
      int nBinsX = 0;
      float xlow = 0, xup = 0, ylow = 0, yup = 0;
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "nBinsX", nBinsX)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "xlow", xlow)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "xup", xup)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "ylow", ylow)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "yup", yup)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "name", name)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "title", title)) {
        return nullptr;
      }
      TProfileAllocator allocator;
      return allocator.create(name.c_str(), title.c_str(), nBinsX, xlow, xup, ylow, yup);
    }
    
    //-------------------------------------------------------------------------------------------------
    
    TObject* TProfile2DXMLAllocator::create(TiXmlElement *element) const {
      if(nullptr == element) {
        return nullptr;
      }
      std::string name, title;
      int nBinsX = 0, nBinsY = 0;
      float xlow = 0, xup = 0, ylow = 0, yup = 0, zlow = 0, zup = 0;
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "nBinsX", nBinsX)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "nBinsY", nBinsY)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "xlow", xlow)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "xup", xup)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "ylow", ylow)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "yup", yup)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "zlow", zlow)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "zup", zup)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "name", name)) {
        return nullptr;
      }
      if(STATUS_CODE_SUCCESS != XmlHelper::getAttribute(element, "title", title)) {
        return nullptr;
      }
      TProfile2DAllocator allocator;
      return allocator.create(name.c_str(), title.c_str(), nBinsX, xlow, xup, nBinsY, ylow, yup, zlow, zup);
    }

  }
  
}
