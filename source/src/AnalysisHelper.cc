/// \file AnalysisHelper.cc
/*
 *
 * AnalysisHelper.cc source template automatically generated by a class generator
 * Creation date : mar. juil. 1 2014
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Tom Coates
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include <dqm4hep/AnalysisHelper.h>
#include <typeinfo>
#include <TH2.h>

namespace dqm4hep {

  namespace core {

    float AnalysisHelper::mean(MonitorElement* pMonitorElement, float percentage)
    {

      std::string ObjectType;

      float result = 0.0;

      //TObject *ThisObject = pMonitorElement->objectTo<TObject>();

      if (nullptr != pMonitorElement->objectTo<TGraph>() && pMonitorElement->type() == "TGraph") {
	ObjectType = "TGraph";
      }
      else if (nullptr != pMonitorElement->objectTo<TH1>()){
	ObjectType = "TH1";
      }
      else {
	dqm_error("The monitor element {0} of type {1} could not be recognised.", pMonitorElement->name(), pMonitorElement->type());
	throw StatusCodeException(STATUS_CODE_FAILURE);
      }

      if(fabs(percentage - 1.f) < std::numeric_limits<float>::epsilon()) {
	if (ObjectType == "TH1") {
	  TH1 *h = pMonitorElement->objectTo<TH1>();
	  result = h->GetMean(1);
	}
	if (ObjectType == "TGraph") {
	  TGraph *h = pMonitorElement->objectTo<TGraph>();
	  result = h->GetMean(1);
	}
      }
      else {

	if (ObjectType == "TH1") {
	  //TH1 *h = (TH1*)(ThisObject);
	  TH1 *h = pMonitorElement->objectTo<TH1>();
	  
	  TAxis *axis = h->GetXaxis();
	  int nbins = axis->GetNbins();
	  int imean = axis->FindBin(h->GetMean());
	  float entries = percentage*h->GetEntries();
	  float w = h->GetBinContent(imean);
	  float x = h->GetBinCenter(imean);

	  float sumw = w;
	  float sumwx = w*x;

	  for (int i=1;i<nbins;i++) {
	    if (i>0) {
	      w = h->GetBinContent(imean-i);
	      x = h->GetBinCenter(imean-i);
	      sumw += w;
	      sumwx += w*x;
	    }
	    if (i<= nbins) {
	      w = h->GetBinContent(imean+i);
	      x = h->GetBinCenter(imean+i);
	      sumw += w;
	      sumwx += w*x;
	    }
	    if (sumw > entries) break;
	  }
	  result = sumwx/sumw;
	}

	if (ObjectType == "TGraph") {
	  //TGraph *h = (TGraph*)(ThisObject);
	  TGraph *h = pMonitorElement->objectTo<TGraph>();

	  double* arrayX = h->GetX();
	  int entries = h->GetHistogram()->GetNbinsX();
	  int startNum = 0.5*(1.0-percentage)*entries;
	  int endNum = entries-startNum;
	  double sum = 0.0;

	  for (int i=startNum; i<endNum; i++) {
	    sum += arrayX[i];
	  }

	  result = sum/(percentage*entries);
	}
      }
      return result;
    }

    float AnalysisHelper::mean90(MonitorElement* pMonitorElement)
    {
      return AnalysisHelper::mean(pMonitorElement, 0.9);
    }

    float AnalysisHelper::rms(MonitorElement* pMonitorElement, float percentage)
    {
      std::string ObjectType;

      float result = 0.0;

      //TObject *ThisObject = pMonitorElement->objectTo<TObject>();

      if (nullptr != pMonitorElement->objectTo<TGraph>() && pMonitorElement->type() == "TGraph") {
	ObjectType = "TGraph";
      }
      else if (nullptr != pMonitorElement->objectTo<TH1>()){
	ObjectType = "TH1";
      }
      else {
	dqm_error("The monitor element {0} of type {1} could not be recognised.", pMonitorElement->name(), pMonitorElement->type());
	throw StatusCodeException(STATUS_CODE_FAILURE);
      }

      if (nullptr != pMonitorElement->objectTo<TGraph>() && pMonitorElement->type() == "TGraph") {
	ObjectType = "TGraph";
      }
      else if (nullptr != pMonitorElement->objectTo<TH1>()){
	ObjectType = "TH1";
      }
      else {
	dqm_error("The monitor element {0} of type {1} could not be recognised.", pMonitorElement->name(), pMonitorElement->type());
	throw StatusCodeException(STATUS_CODE_FAILURE);
      }

      if(fabs(percentage - 1.f) < std::numeric_limits<float>::epsilon()) {
	if (ObjectType == "TH1") {
	  TH1 *h = pMonitorElement->objectTo<TH1>();
	  result = h->GetRMS(1);
	}
	if (ObjectType == "TGraph") {
	  TGraph *h = pMonitorElement->objectTo<TGraph>();
	  result = h->GetRMS(1);
	}
      }
      else {

	if (ObjectType == "TH1") {
	  //TH1 *h = (TH1*)(ThisObject);
	  TH1 *h = pMonitorElement->objectTo<TH1>();

	  TAxis *axis = h->GetXaxis();
	  int nbins = axis->GetNbins();
	  int imean = axis->FindBin(h->GetMean());
	  float entries = percentage*h->GetEntries();
	  float w = h->GetBinContent(imean);
	  float x = h->GetBinCenter(imean);
	  float mean = h->GetMean();

	  float sumw = w;
	  float sumwx = w*pow(x-mean,2);

	  for (int i=1;i<nbins;i++) {
	    if (i>0) {
	      w = h->GetBinContent(imean-i);
	      x = h->GetBinCenter(imean-i);
	      sumw += w;
	      sumwx += w*pow(x-mean,2);
	    }
	    if (i<= nbins) {
	      w = h->GetBinContent(imean+i);
	      x = h->GetBinCenter(imean+i);
	      sumw += w;
	      sumwx += w*pow(x-mean,2);
	    }
	    if (sumw > entries) break;
	  }
	  result = pow(sumwx/sumw,0.5);
	}
	if (ObjectType == "TGraph") {
	  percentage = 0.9;
	  //TGraph *h = (TGraph*)(ThisObject);
	  TGraph *h = pMonitorElement->objectTo<TGraph>();

	  double* arrayX = h->GetX();
	  int entries = h->GetHistogram()->GetNbinsX();
	  int startNum = 0.5*(1.0-percentage)*entries;
	  int endNum = entries-startNum;
	  double sum = 0.0;
	  float mean = h->GetMean(1);

	  for (int i=startNum; i<endNum; i++) {
	    sum += pow(arrayX[i]-mean,2);
	  }

	  result = pow(sum/(percentage*entries),0.5);
	}
      }
      return result;
    }

    float AnalysisHelper::rms90(MonitorElement* pMonitorElement)
    {
      return AnalysisHelper::rms(pMonitorElement, 0.9);
    }

    float AnalysisHelper::median(MonitorElement* pMonitorElement)
    {
      // This method works ONLY for a TH1 and must be changed to handle a TGraph
      TH1 *h = pMonitorElement->objectTo<TH1>();

      Double_t xq[1];
      Double_t yq[1];
      xq[0] = 0.5;

      h->GetQuantiles(1, yq, xq);
      float result = yq[0];

      return result;
    }

  }

}
