/// \file Run.cc
/*
 *
 * Run.cc source template automatically generated by a class generator
 * Creation date : dim. mars 29 2015
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

#include <dqm4hep/Run.h>
#include <dqm4hep/StreamingHelper.h>

namespace dqm4hep {

  namespace core {

    Run::Run(int rn, const std::string &des, const std::string &dn) : 
      m_runNumber(rn),
      m_startTime(dqm4hep::core::now()),
      m_detectorName(dn),
      m_description(des) {
      /* nop */
    }

    //-------------------------------------------------------------------------------------------------

    StringVector Run::parameterKeys() const {
      StringVector keys;
      for (auto iter = m_parametersMap.begin(), endIter = m_parametersMap.end(); endIter != iter; ++iter)
        keys.push_back(iter->first);
      return keys;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    const StringMap &Run::parameters() const {
      return m_parametersMap;
    }

    //-------------------------------------------------------------------------------------------------

    void Run::reset() {
      m_runNumber = 0;
      m_startTime = TimePoint();
      m_endTime = TimePoint();
      m_detectorName.clear();
      m_description.clear();
      m_parametersMap.clear();
    }

    //-------------------------------------------------------------------------------------------------

    void Run::toJson(json &value) const {
      auto st = std::chrono::system_clock::to_time_t(m_startTime);
      auto et = std::chrono::system_clock::to_time_t(m_endTime);
      value = {
        {"runNumber", m_runNumber},
        {"startTime", st},
        {"endTime", et},
        {"detector", m_detectorName},
        {"description", m_description}, 
        {"parameters", m_parametersMap}
      };
    }

    //-------------------------------------------------------------------------------------------------

    void Run::fromJson(const json &value) {
      m_runNumber = value.value<int>("runNumber", 0);
      auto st = value.value<int64_t>("startTime", 0);
      auto et = value.value<int64_t>("endTime", 0);
      m_startTime = std::chrono::system_clock::from_time_t(st);
      m_endTime = std::chrono::system_clock::from_time_t(et);
      m_detectorName = value.value<std::string>("detector", "");
      m_description = value.value<std::string>("description", "");
      m_parametersMap = value.value<StringMap>("parameters", StringMap());
    }
    
    //-------------------------------------------------------------------------------------------------
    
    std::ostream& operator<<(std::ostream &out, const Run &run) {
      core::json jrun;
      run.toJson(jrun);
      out << jrun.dump(2);
      return out;
    }
  }
}
