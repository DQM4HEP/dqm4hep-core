/// \file Run.cc
/*
 *
 * Run.cc source template automatically generated by a class generator
 * Creation date : dim. mars 29 2015
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

#include <dqm4hep/Run.h>
#include <dqm4hep/StreamingHelper.h>

namespace dqm4hep {

  namespace core {

    Run::Run(int runNumber, const std::string &description, const std::string &detectorName)
        : m_runNumber(runNumber),
          m_startTime(dqm4hep::core::now()),
          m_endTime(),
          m_detectorName(detectorName),
          m_description(description),
          m_parametersMap() {
      /* nop */
    }

    //-------------------------------------------------------------------------------------------------

    StringVector Run::getParameterKeys() const {
      StringVector keys;

      for (auto iter = m_parametersMap.begin(), endIter = m_parametersMap.end(); endIter != iter; ++iter)
        keys.push_back(iter->first);

      return keys;
    }

    //-------------------------------------------------------------------------------------------------

    void Run::reset() {
      m_runNumber = 0;
      m_startTime = TimePoint();
      m_endTime = TimePoint();
      m_detectorName.clear();
      m_description.clear();
      m_parametersMap.clear();
    }

    //-------------------------------------------------------------------------------------------------

    void Run::toJson(json &value) const {
      auto startTime = std::chrono::system_clock::to_time_t(m_startTime);
      auto endTime = std::chrono::system_clock::to_time_t(m_endTime);

      value = {{"runNumber", m_runNumber},   {"startTime", startTime},       {"endTime", endTime},
               {"detector", m_detectorName}, {"description", m_description}, {"parameters", m_parametersMap}};
    }

    //-------------------------------------------------------------------------------------------------

    void Run::fromJson(const json &value) {
      m_runNumber = value.value<int>("runNumber", 0);
      auto startTime = value.value<int64_t>("startTime", 0);
      auto endTime = value.value<int64_t>("endTime", 0);
      m_startTime = std::chrono::system_clock::from_time_t(startTime);
      m_endTime = std::chrono::system_clock::from_time_t(endTime);
      m_detectorName = value.value<std::string>("detector", "");
      m_description = value.value<std::string>("description", "");
      m_parametersMap = value.value<StringMap>("parameters", StringMap());
    }
  }
}
