/*
 *
 * Internal.cc source template automatically generated by a class generator
 * Creation date : lun. aoï¿½t 17 2015
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include <dqm4hep/Internal.h>
#include <dqm4hep/Logging.h> // Include here to avoid cycling include in the header

// -- ROOT header
#include <TSystem.h>

#include <cstring>
#include <dirent.h>

namespace dqm4hep {

  namespace core {

#if defined(__linux__)

// -- ROOT header
#include <TPRegexp.h>

#if defined(DQM4HEP_WITH_PROC_FS)
    // only for unix systems
    int getProcValue(const std::string fname, const std::string &entry) {
      FILE *file = fopen(fname.c_str(), "r");
      int result = -1;
      char line[128];

      while (fgets(line, 128, file) != nullptr) {
        if (strncmp(line, entry.c_str(), entry.size()) == 0) {
          int i = strlen(line);
          const char *p = line;
          while (*p < '0' || *p > '9') {
            p++;
          }
          line[i - 3] = '\0';
          result = atoi(p);
          break;
        }
      }
      fclose(file);
      return result;
    }
#endif // DQM4HEP_WITH_PROC_FS

    //-------------------------------------------------------------------------------------------------
    /// Read CPU load on Linux.

    static void readLinuxCpu(long *ticks) {
      ticks[0] = ticks[1] = ticks[2] = ticks[3] = 0;

      TString s;
      FILE *f = fopen("/proc/stat", "r");

      if (!f) {
        dqm_error("[{0}] - Failed to open '/proc/stat'", __FUNCTION__);
        throw core::StatusCodeException(STATUS_CODE_FAILURE);
      }

      s.Gets(f);
      // user, user nice, sys, idle
      sscanf(s.Data(), "%*s %ld %ld %ld %ld", &ticks[0], &ticks[3], &ticks[1], &ticks[2]);
      fclose(f);
    }

    //-------------------------------------------------------------------------------------------------
    /// Get CPU stat for Linux. Use sampleTime to set the interval over which
    /// the CPU load will be measured, in s (default 1).

    static void linuxCpuStats(CpuStats &stats, dqm_int sampleTime) {
      dqm_double avg[3] = {-1.};
#ifndef R__WINGCC
      if (getloadavg(avg, sizeof(avg)) < 0) {
        // ::Error("getLinuxCpuInfo", "getloadavg failed");
        dqm_error("[{0}] - Failed to getloadavg'", __FUNCTION__);
        throw core::StatusCodeException(STATUS_CODE_FAILURE);
      } else
#endif // R__WINGCC
      {
        stats.load1m = (dqm_float)avg[0];
        stats.load5m = (dqm_float)avg[1];
        stats.load15m = (dqm_float)avg[2];
      }

      dqm_long cpu_ticks1[4] = {0L};
      dqm_long cpu_ticks2[4] = {0L};
      readLinuxCpu(cpu_ticks1);
      ::sleep(sampleTime);
      readLinuxCpu(cpu_ticks2);

      dqm_long userticks = (cpu_ticks2[0] + cpu_ticks2[3]) - (cpu_ticks1[0] + cpu_ticks1[3]);
      dqm_long systicks = cpu_ticks2[1] - cpu_ticks1[1];
      dqm_long idleticks = cpu_ticks2[2] - cpu_ticks1[2];
      if (userticks < 0)
        userticks = 0;
      if (systicks < 0)
        systicks = 0;
      if (idleticks < 0)
        idleticks = 0;
      dqm_long totalticks = userticks + systicks + idleticks;
      if (totalticks) {
        stats.user = ((dqm_float)(100 * userticks)) / ((dqm_float)totalticks);
        stats.sys = ((dqm_float)(100 * systicks)) / ((dqm_float)totalticks);
        stats.tot = stats.user + stats.sys;
        stats.idle = ((dqm_float)(100 * idleticks)) / ((dqm_float)totalticks);
      }
    }

    //-------------------------------------------------------------------------------------------------
    /// Get VM stat for Linux.

    static void linuxMemStats(MemoryStats &stats) {
      TString s;
      FILE *f = fopen("/proc/meminfo", "r");
      if (!f) {
        dqm_error("[{0}] - Failed to open '/proc/meminfo'", __FUNCTION__);
        throw core::StatusCodeException(STATUS_CODE_FAILURE);
      }
      dqm_long_long free = {0LL};
      dqm_long_long total = {0LL};

      dqm_long_long swap_total = {0LL};
      dqm_long_long swap_free = {0LL};

      while (s.Gets(f)) {
        if (s.BeginsWith("MemTotal")) {
          TPRegexp("^.+: *([^ ]+).*").Substitute(s, "$1");
          total = (s.Atoi() / 1024);
        }
        if (s.BeginsWith("MemFree")) {
          TPRegexp("^.+: *([^ ]+).*").Substitute(s, "$1");
          free = (s.Atoi() / 1024);
        }
        if (s.BeginsWith("SwapTotal")) {
          TPRegexp("^.+: *([^ ]+).*").Substitute(s, "$1");
          swap_total = (s.Atoi() / 1024);
        }
        if (s.BeginsWith("SwapFree")) {
          TPRegexp("^.+: *([^ ]+).*").Substitute(s, "$1");
          swap_free = (s.Atoi() / 1024);
        }
      }
      fclose(f);

      stats.vmTot = (dqm_int)(total + swap_total);
      stats.vmUsed = (dqm_int)(total - free);
      stats.vmFree = (dqm_int)(free + swap_free);
      stats.rssTot = (dqm_int)(total >> 20);
      stats.rssUsed = (dqm_int)((total - free) >> 20);
    }

    //-------------------------------------------------------------------------------------------------
    /// Get process info for this process on Linux.

    static void linuxProcStats(ProcessStats &stats) {
      struct rusage ru;
      if (getrusage(RUSAGE_SELF, &ru) < 0) {
        // ::SysError("getLinuxProcInfo", "getrusage failed");
        dqm_error("[{0}] - Failed to getrusage", __FUNCTION__);
        throw core::StatusCodeException(STATUS_CODE_FAILURE);
      } else {
        stats.cpuTimeUser = (dqm_float)(ru.ru_utime.tv_sec) + ((dqm_float)(ru.ru_utime.tv_usec) / 1000000.);
        stats.cpuTimeSys = (dqm_float)(ru.ru_stime.tv_sec) + ((dqm_float)(ru.ru_stime.tv_usec) / 1000000.);

        //  TODO: Compute proc cpu load here
        dqm_warning("[{0}] - Process cpu load has not been implemented yet!", __FUNCTION__);
        stats.cpuUser = -1;
        stats.cpuSys = -1;
        stats.cpuTot = -1;
      }

      stats.vm = -1;
      stats.rss = -1;
      TString s;
      FILE *f = fopen(TString::Format("/proc/%d/statm", gSystem->GetPid()), "r");
      if (f) {
        s.Gets(f);
        fclose(f);
        dqm_long total = {0L};
        dqm_long rss = {0L};
        sscanf(s.Data(), "%ld %ld", &total, &rss);
        stats.vm = total * (getpagesize() / 1024);
        stats.rss = rss * (getpagesize() / 1024);
      }
    }

    //-------------------------------------------------------------------------------------------------

    static void linuxNetStats(NetworkStats &stats) {
#if defined(DQM4HEP_WITH_PROC_FS)
      FILE *file = fopen("/proc/net/dev", "r");

      // skip first two lines
      if (fscanf(file, "%*[^\n]\n") == EOF or fscanf(file, "%*[^\n]\n") == EOF) {
        return;
      }

      while (1) {
        // get interface name
        std::string iname;
        char c;
        do {
          c = fgetc(file);
          if (c == ':')
            break;
          iname += c;
        } while (c != EOF && c != '\n');

        if (c == EOF)
          break;

        INetworkStats stat;

        // read received stats
        if (fscanf(file, "%lu %lu %lu", &stat.tot_rcv_kbytes, &stat.tot_rcv_packets, &stat.tot_rcv_errs) == EOF) {
          return;
        }

        // skip uneeded fields
        dqm_stat dummy;
        if (EOF == fscanf(file, "%lu %lu %lu %lu %lu", &dummy, &dummy, &dummy, &dummy, &dummy))
          break;

        // read send stats
        if (fscanf(file, "%lu %lu %lu", &stat.tot_snd_kbytes, &stat.tot_snd_packets, &stat.tot_snd_errs) == EOF) {
          return;
        }

        if (EOF == fscanf(file, "%*[^\n]\n"))
          break;

      // TODO: Compute rate
        stat.rcv_rate_kbytes = 0;
        stat.rcv_rate_packets = 0;
        stat.rcv_rate_errs = 0;
        stat.snd_rate_kbytes = 0;
        stat.snd_rate_packets = 0;
        stat.snd_rate_errs = 0;
        stats[iname] = stat;
      }
      // TODO: Compute rate, Warning displayed here to not pollute logs for each interface
      dqm_warning("[{0}] - Network rate has not been implemented yet!", __FUNCTION__);

      fclose(file);
#endif // DQM4HEP_WITH_PROC_FS
    }

#endif // __linux__

    //---- System, CPU and Memory info ---------------------------------------------

#if defined(__APPLE__)
#include <mach/mach.h>
#include <mach/mach_error.h>
#include <net/if.h>
#include <net/if_dl.h>
#include <net/route.h>
#include <sys/resource.h>
#include <sys/sysctl.h>

    ////////////////////////////////////////////////////////////////////////////////
    /// Get CPU load on Mac OS X.

    static void readDarwinCpu(long *ticks) {
      ticks[0] = ticks[1] = ticks[2] = ticks[3] = 0;

      host_cpu_load_info_data_t cpu;
      mach_msg_type_number_t count = HOST_CPU_LOAD_INFO_COUNT;

      kern_return_t kr = host_statistics(mach_host_self(), HOST_CPU_LOAD_INFO, (host_info_t)&cpu, &count);
      if (kr != KERN_SUCCESS) {
        dqm_error("[{0}] - Failed to get host_statistics: {1}", __FUNCTION__, mach_error_string(kr));
        throw core::StatusCodeException(STATUS_CODE_FAILURE);
      } else {
        ticks[0] = cpu.cpu_ticks[CPU_STATE_USER];
        ticks[1] = cpu.cpu_ticks[CPU_STATE_SYSTEM];
        ticks[2] = cpu.cpu_ticks[CPU_STATE_IDLE];
        ticks[3] = cpu.cpu_ticks[CPU_STATE_NICE];
      }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /// Get CPU stat for Mac OS X. Use sampleTime to set the interval over which
    /// the CPU load will be measured, in s (default 1).

    static void darwinCpuStats(CpuStats &stats, dqm_int sampleTime) {
      dqm_double avg[3] = {-1.};
      if (getloadavg(avg, sizeof(avg)) < 0) {
        // ::Error("darwinCpuStats", "getloadavg failed");
        dqm_error("[{0}] - Failed to getloadavg", __FUNCTION__);
        throw core::StatusCodeException(STATUS_CODE_FAILURE);
      } else {
        stats.load1m = (dqm_float)avg[0];
        stats.load5m = (dqm_float)avg[1];
        stats.load15m = (dqm_float)avg[2];
      }

      dqm_long cpu_ticks1[4] = {0L};
      dqm_long cpu_ticks2[4] = {0L};
      readDarwinCpu(cpu_ticks1);
      ::sleep(sampleTime);
      readDarwinCpu(cpu_ticks2);

      dqm_long userticks = (cpu_ticks2[0] + cpu_ticks2[3]) - (cpu_ticks1[0] + cpu_ticks1[3]);
      dqm_long systicks = cpu_ticks2[1] - cpu_ticks1[1];
      dqm_long idleticks = cpu_ticks2[2] - cpu_ticks1[2];
      if (userticks < 0)
        userticks = 0;
      if (systicks < 0)
        systicks = 0;
      if (idleticks < 0)
        idleticks = 0;
      dqm_long totalticks = userticks + systicks + idleticks;
      if (totalticks) {
        stats.user = ((dqm_float)(100 * userticks)) / ((dqm_float)totalticks);
        stats.sys = ((dqm_float)(100 * systicks)) / ((dqm_float)totalticks);
        stats.tot = stats.user + stats.sys;
        stats.idle = ((dqm_float)(100 * idleticks)) / ((dqm_float)totalticks);
      }
    }

    ////////////////////////////////////////////////////////////////////////////////
    /// Get VM stat for Mac OS X.

    static void darwinMemStats(MemoryStats &stats) {
      vm_statistics_data_t vm_info;
      mach_msg_type_number_t count = HOST_VM_INFO_COUNT;

      kern_return_t kr = host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&vm_info, &count);
      if (kr != KERN_SUCCESS) {
        // ::Error("getDarwinMemInfo", "host_statistics: %s", mach_error_string(kr));
        dqm_error("[{0}] - Failed to get host_statistics: {1}", __FUNCTION__, mach_error_string(kr));
        throw core::StatusCodeException(STATUS_CODE_FAILURE);
      }
      static dqm_int pshift = 0;
      if (pshift == 0) {
        for (int psize = getpagesize(); psize > 1; psize >>= 1) {
          pshift++;
        }
      }

      dqm_long_long used = (dqm_long_long)(vm_info.active_count + vm_info.inactive_count + vm_info.wire_count)
                           << pshift;
      dqm_long_long free = (dqm_long_long)(vm_info.free_count) << pshift;
      dqm_long_long total =
          (dqm_long_long)(vm_info.active_count + vm_info.inactive_count + vm_info.free_count + vm_info.wire_count)
          << pshift;

      // Swap is available at same time as mem, so grab values here.
      dqm_long_long swap_used = vm_info.pageouts << pshift;

      // Figure out total swap. This adds up the size of the swapfiles */
      static DIR *dirp = nullptr;
      dirp = opendir("/private/var/vm");
      if (!dirp) {
        dqm_error("[{0}] - Failed to get vm file", __FUNCTION__);
        throw core::StatusCodeException(STATUS_CODE_FAILURE);
        // return;
      }

      dqm_long_long swap_total = 0;
      struct dirent *dp = nullptr;

      while ((dp = readdir(dirp)) != 0) {
        struct stat sb;
        char fname[MAXNAMLEN];
        if (strncmp(dp->d_name, "swapfile", 8))
          continue;
        strlcpy(fname, "/private/var/vm/", MAXNAMLEN);
        strlcat(fname, dp->d_name, MAXNAMLEN);
        if (stat(fname, &sb) < 0)
          continue;
        swap_total += sb.st_size;
      }
      closedir(dirp);

      stats.vmTot = (dqm_int)((total + swap_total) >> 20); // divide by 1024 * 1024
      stats.vmUsed = (dqm_int)((used + swap_used) >> 20);
      stats.vmFree = (dqm_int)((free + swap_total - swap_used) >> 20);
      stats.rssTot = (dqm_int)(total >> 20);
      stats.rssUsed = (dqm_int)(used >> 20);
    }

    //-------------------------------------------------------------------------------------------------
    /// Get process info for this process on Mac OS X.
    /// Code largely taken from:
    /// http://www.opensource.apple.com/source/top/top-15/libtop.c
    /// The virtual memory usage is slightly over estimated as we don't
    /// subtract shared regions, but the value makes more sense
    /// then pure vsize, which is useless on 64-bit machines.

    static void darwinProcStats(ProcessStats &stats) {
#ifdef _LP64
#define vm_region vm_region_64
#endif

// taken from <mach/shared_memory_server.h> which is obsoleted in 10.5
#define GLOBAL_SHARED_TEXT_SEGMENT 0x90000000U
#define GLOBAL_SHARED_DATA_SEGMENT 0xA0000000U
#define SHARED_TEXT_REGION_SIZE 0x10000000
#define SHARED_DATA_REGION_SIZE 0x10000000

      struct rusage ru;
      if (getrusage(RUSAGE_SELF, &ru) < 0) {
        dqm_error("[{0}] - Failed to getrusage", __FUNCTION__);
        throw core::StatusCodeException(STATUS_CODE_FAILURE);
      } else {
        stats.cpuTimeUser = (dqm_float)(ru.ru_utime.tv_sec) + ((dqm_float)(ru.ru_utime.tv_usec) / 1000000.);
        stats.cpuTimeSys = (dqm_float)(ru.ru_stime.tv_sec) + ((dqm_float)(ru.ru_stime.tv_usec) / 1000000.);

        //TODO: Compute proc cpu load here
        dqm_warning("[{0}] - Process cpu load has not been implemented yet!", __FUNCTION__);
        stats.cpuUser = -1;
        stats.cpuSys = -1;
        stats.cpuTot = -1;

      }

      task_t a_task = mach_task_self();
      task_basic_info_data_t ti;
      mach_msg_type_number_t count = TASK_BASIC_INFO_COUNT;

      kern_return_t kr = task_info(a_task, TASK_BASIC_INFO, (task_info_t)&ti, &count);
      if (kr != KERN_SUCCESS) {
        dqm_error("[{0}] - Failed to get task_info: {1}", __FUNCTION__, mach_error_string(kr));
        throw core::StatusCodeException(STATUS_CODE_FAILURE);
      } else {
        // resident size does not require any calculation. Virtual size
        // needs to be adjusted if traversing memory objects do not include the
        // globally shared text and data regions
        mach_port_t object_name;
        vm_address_t address;
        vm_region_top_info_data_t info;

        vm_size_t rsize = ti.resident_size;
        vm_size_t vsize = ti.virtual_size;
        vm_size_t vprvt = 0;
        vm_size_t size = 0;

        for (address = 0;; address += size) {
          // get memory region
          count = VM_REGION_TOP_INFO_COUNT;
          if (vm_region(a_task, &address, &size, VM_REGION_TOP_INFO, (vm_region_info_t)&info, &count, &object_name) !=
              KERN_SUCCESS) {
            // no more memory regions.
            break;
          }

          if (address >= GLOBAL_SHARED_TEXT_SEGMENT &&
              address < (GLOBAL_SHARED_DATA_SEGMENT + SHARED_DATA_REGION_SIZE)) {
            // This region is private shared.
            // Check if this process has the globally shared
            // text and data regions mapped in. If so, adjust
            // virtual memory size and exit loop.
            if (info.share_mode == SM_EMPTY) {
              vm_region_basic_info_data_64_t b_info;
              count = VM_REGION_BASIC_INFO_COUNT_64;
              if (vm_region_64(a_task, &address, &size, VM_REGION_BASIC_INFO, (vm_region_info_t)&b_info, &count,
                               &object_name) != KERN_SUCCESS) {
                break;
              }

              if (b_info.reserved) {
                vsize -= (SHARED_TEXT_REGION_SIZE + SHARED_DATA_REGION_SIZE);
                // break;  // only for vsize
              }
            }
            // Short circuit the loop if this isn't a shared
            // private region, since that's the only region
            // type we care about within the current address range.
            if (info.share_mode != SM_PRIVATE) {
              continue;
            }
          }
          switch (info.share_mode) {
          case SM_COW: {
            if (info.ref_count == 1) {
              vprvt += size;
            } else {
              vprvt += info.private_pages_resident * getpagesize();
            }
            break;
          }
          case SM_PRIVATE: {
            vprvt += size;
            break;
          }
          default:
            break;
          }
        }

        stats.vm = (dqm_long)(rsize / 1024.);
        stats.rss = (dqm_long)(vprvt / 1024.);
      }
    }

    //-------------------------------------------------------------------------------------------------
    static void readDarwinNet(NetworkStats &stats) {
      double unit = 1024.; // Store everything in kb

      // Get sizing info from sysctl and resize as needed.
      int mib[] = {CTL_NET, PF_ROUTE, 0, 0, NET_RT_IFLIST, 0};
      size_t currentSize{0};
      if (sysctl(mib, 6, NULL, &currentSize, NULL, 0) != 0) {
        const int errNum = errno;
        dqm_error("[{0}] - Failed to get network buffer size: {1}", __FUNCTION__, errNum);
        throw core::StatusCodeException(STATUS_CODE_FAILURE);
      }
      size_t sysctlBufferSize{0};
      uint8_t *sysctlBuffer = nullptr;
      if (!sysctlBuffer || (currentSize > sysctlBufferSize)) {
        if (sysctlBuffer)
          free(sysctlBuffer);
        sysctlBufferSize = 0;
        sysctlBuffer = (uint8_t *)malloc(currentSize);
        if (!sysctlBuffer) {
          const int errNum = errno;
          dqm_error("[{0}] - Failed to get network statistics: {1}", __FUNCTION__, errNum);
          throw core::StatusCodeException(STATUS_CODE_FAILURE);
        }
        sysctlBufferSize = currentSize;
      }

      // Read in new data
      if (sysctl(mib, 6, sysctlBuffer, &currentSize, NULL, 0) != 0) {
        const int errNum = errno;
        dqm_error("[{0}] - Failed to read network statistics: {1}", __FUNCTION__, errNum);
        throw core::StatusCodeException(STATUS_CODE_FAILURE);
      }

      // Walk through the reply
      uint8_t *currentData = sysctlBuffer;
      uint8_t *currentDataEnd = sysctlBuffer + currentSize;

      while (currentData < currentDataEnd) {
        // Expecting interface data
        struct if_msghdr *ifmsg = (struct if_msghdr *)currentData;
        if (ifmsg->ifm_type != RTM_IFINFO) {
          currentData += ifmsg->ifm_msglen;
          continue;
        }

        // Only look at link layer items
        struct sockaddr_dl *sdl = (struct sockaddr_dl *)(ifmsg + 1);
        if (sdl->sdl_family != AF_LINK) {
          currentData += ifmsg->ifm_msglen;
          continue;
        }

        // Get interface name
        char ifc_name[32];
        strncpy(ifc_name, sdl->sdl_data, sdl->sdl_nlen);
        ifc_name[sdl->sdl_nlen] = 0;

        INetworkStats stat;
        stat.tot_rcv_kbytes = ifmsg->ifm_data.ifi_ibytes / unit;
        stat.tot_rcv_packets = ifmsg->ifm_data.ifi_ipackets;
        stat.tot_rcv_errs = ifmsg->ifm_data.ifi_ierrors;
        stat.tot_snd_kbytes = ifmsg->ifm_data.ifi_obytes / unit;
        stat.tot_snd_packets = ifmsg->ifm_data.ifi_opackets;
        stat.tot_snd_errs = ifmsg->ifm_data.ifi_oerrors;
        stats[ifc_name] = stat;

        currentData += ifmsg->ifm_msglen;
      }
    }
    static void darwinNetStats(NetworkStats &stats, dqm_int sampleTime) {

      NetworkStats tempStats;
      readDarwinNet(tempStats);
      ::sleep(sampleTime);
      readDarwinNet(stats);

      for (const auto &ifcIter : tempStats) {
        auto ifcIter2 = stats.find(ifcIter.first);

        if (ifcIter.first != ifcIter2->first) {
          dqm_error("[{0}] - Wrong interface comparison");
          throw core::StatusCodeException(STATUS_CODE_FAILURE);
        }

        ifcIter2->second.rcv_rate_kbytes =
            (ifcIter2->second.tot_rcv_kbytes - ifcIter.second.tot_rcv_kbytes) / sampleTime;
        ifcIter2->second.rcv_rate_packets =
            (ifcIter2->second.tot_rcv_packets - ifcIter.second.tot_rcv_packets) / sampleTime;
        ifcIter2->second.rcv_rate_errs = (ifcIter2->second.tot_rcv_errs - ifcIter.second.tot_rcv_errs) / sampleTime;
        ifcIter2->second.snd_rate_kbytes =
            (ifcIter2->second.tot_snd_kbytes - ifcIter.second.tot_snd_kbytes) / sampleTime;
        ifcIter2->second.snd_rate_packets =
            (ifcIter2->second.tot_snd_packets - ifcIter.second.tot_snd_packets) / sampleTime;
        ifcIter2->second.snd_rate_errs = (ifcIter2->second.tot_snd_errs - ifcIter.second.tot_snd_errs) / sampleTime;
      }
    }

#endif // __APPLE__

#if defined(_WIN32)
    static void winCpuStats(CpuStats &stats, dqm_int sampleTime){
      /* WINDOWS implementation: TBD */
      dqm_warning("[{0}] - has not been implemented!", __FUNCTION__);
      throw core::StatusCodeException(STATUS_CODE_NOT_FOUND);
    }

    //-------------------------------------------------------------------------------------------------

    static void winMemStats(MemoryStats &stats) {
      /* WINDOWS implementation: TBD */
      dqm_warning("[{0}] - has not been implemented!", __FUNCTION__);
      throw core::StatusCodeException(STATUS_CODE_NOT_FOUND);
    }

    //-------------------------------------------------------------------------------------------------

    static void winProcStats(ProcessStats &stats) {
      /* WINDOWS implementation: TBD */
      dqm_warning("[{0}] - has not been implemented!", __FUNCTION__);
      throw core::StatusCodeException(STATUS_CODE_NOT_FOUND);
    }

    //-------------------------------------------------------------------------------------------------

    static void winNetStats(NetworkStats &stats, dqm_int sampleTime) {
      /* WINDOWS implementation: TBD */
      dqm_warning("[{0}] - has not been implemented!", __FUNCTION__);
      throw core::StatusCodeException(STATUS_CODE_NOT_FOUND);
    }


#endif //_WIN32

    //-------------------------------------------------------------------------------------------------
    /// Returns cpu load average and load info into the CpuInfo_t structure.
    /// Use sampleTime to set the interval over which the CPU load will be measured,
    /// In ms (default 1000).

    void cpuStats(CpuStats &stats, dqm_int sampleTime) {
#if defined(__APPLE__)
      darwinCpuStats(stats, sampleTime);
#elif defined(__linux__)
      linuxCpuStats(stats, sampleTime);
#elif defined(_WIN32)
      winCpuStats(stats, sampleTime);
#else
#error "Unrecognized OS plateform (not windows, linux, OSX or unix) !"
#endif
    }

    //-------------------------------------------------------------------------------------------------
    /// Returns ram and swap memory usage info into the MemInfo_t structure.

    void memStats(MemoryStats &stats) {
#if defined(__APPLE__)
      darwinMemStats(stats);
#elif defined(__linux__)
      linuxMemStats(stats);
#elif defined(_WIN32)
      winMemStats(stats);
#else
#error "Unrecognized OS plateform (not windows, linux, OSX or unix) !"
#endif
    }

    //-------------------------------------------------------------------------------------------------
    /// Returns cpu and memory used by this process into the ProcInfo_t structure.

    void procStats(ProcessStats &stats) {
#if defined(__APPLE__)
      darwinProcStats(stats);
#elif defined(__linux__)
      linuxProcStats(stats);
#elif defined(_WIN32)
      winProcStats(stats);
#else
#error "Unrecognized OS plateform (not windows, linux, OSX or unix) !"
#endif
    }

    //-------------------------------------------------------------------------------------------------
    /// Returns network and memory used by this process into the ProcInfo_t structure.

    void netStats(NetworkStats &stats, dqm_int sampleTime) {
#if defined(__APPLE__)
      darwinNetStats(stats, sampleTime);
#elif defined(__linux__)
      linuxNetStats(stats, sampleTime);
#elif defined(_WIN32)
      winNetStats(stats, sampleTime);
#else
#error "Unrecognized OS plateform (not windows, linux, OSX or unix) !"
#endif
    }
  } // namespace core
} // namespace dqm4hep
